<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0039)http://stein.cshl.org/WWW/software/CGI/ -->
<HTML><HEAD><TITLE>CGI.pm - a Perl5 CGI Library</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><!-- $Id -->
<META content="MSHTML 5.50.4916.2300" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<H1><IMG alt=[logo] src="CGI_pm-aPerl5CGI_Library_files/dna.small.gif"> CGI.pm - 
a Perl5 CGI Library</H1>Version 2.81, 4/11/2002, L. Stein 
<P>
<H2>Abstract</H2>This perl 5 library uses objects to create Web fill-out forms 
on the fly and to parse their contents. It provides a simple interface for 
parsing and interpreting query strings passed to CGI scripts. However, it also 
offers a rich set of functions for creating fill-out forms. Instead of 
remembering the syntax for HTML form elements, you just make a series of perl 
function calls. An important fringe benefit of this is that the value of the 
previous query is used to initialize the form, so that the state of the form is 
preserved from invocation to invocation. 
<P>Everything is done through a ``CGI'' object. When you create one of these 
objects it examines the environment for a query string, parses it, and stores 
the results. You can then ask the CGI object to return or modify the query 
values. CGI objects handle POST and GET methods correctly, and correctly 
distinguish between scripts called from &lt;ISINDEX&gt; documents and form-based 
documents. In fact you can debug your script from the command line without 
worrying about setting up environment variables. 
<P>A script to create a fill-out form that remembers its state each time it's 
invoked is very easy to write with CGI.pm: <PRE>#!/usr/local/bin/perl

use CGI qw(:standard);

print header;
print start_html('A Simple Example'),
    h1('A Simple Example'),
    start_form,
    "What's your name? ",textfield('name'),
    p,
    "What's the combination?",
    p,
    checkbox_group(-name=&gt;'words',
		   -values=&gt;['eenie','meenie','minie','moe'],
		   -defaults=&gt;['eenie','minie']),
    p,
    "What's your favorite color? ",
    popup_menu(-name=&gt;'color',
	       -values=&gt;['red','green','blue','chartreuse']),
    p,
    submit,
    end_form,
    hr;

if (param()) {
    print 
	"Your name is",em(param('name')),
	p,
	"The keywords are: ",em(join(", ",param('words'))),
	p,
	"Your favorite color is ",em(param('color')),
	hr;
}
print end_html;
</PRE><A href="http://stein.cshl.org/WWW/software/CGI/examples/tryit.cgi">Select 
this link to try the script</A> <BR><A 
href="http://stein.cshl.org/WWW/software/CGI/examples/">More scripting 
examples</A> <BR><A 
href="http://www.wiley.com/compbooks/stein/source.html">Source code examples 
from <CITE>The Official Guide to CGI.pm</CITE></A> 
<P>
<H2><A name=contents>Contents</A></H2>
<MENU>
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#download">Downloading</A> 

  <LI><A 
  href="http://stein.cshl.org/WWW/software/CGI/#installation">Installation</A> 
  <LI><A 
  href="http://stein.cshl.org/WWW/software/CGI/#functionvsoo">Function-Oriented 
  vs Object-Oriented Use</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#query">Creating a new CGI 
  query object</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#saving">Saving the state 
  of the form</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#named_param">CGI 
  Functions that Take Multiple Arguments</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#header">Creating the HTTP 
  header</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#html">HTML shortcuts</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#forms">Creating forms</A> 

  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#import">Importing CGI 
  methods</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#errors">Retrieving CGI.pm 
  errors</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#debugging">Debugging</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#environment">HTTP session 
  variables</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#cookies">HTTP Cookies</A> 

  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#frames">Support for 
  frames</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#javascripting">Support 
  for JavaScript</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#stylesheets">Limited 
  Support for Cascading Style Sheets</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#nph">Using NPH 
  Scripts</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#advanced">Advanced 
  techniques</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#subclassing">Subclassing 
  CGI.pm</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#mod_perl">Using CGI.pm 
  with mod_perl and FastCGI</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#migrating">Migrating from 
  cgi-lib.pl</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#upload_caveats">Using the 
  File Upload Feature</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#push">Server Push</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#dos">Avoiding Denial of 
  Service Attacks</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#non_unix">Using CGI.pm on 
  non-Unix Platforms</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#future">The Relationship 
  of CGI.pm to the CGI::* Modules</A> 
  <LI><A 
  href="http://stein.cshl.org/WWW/software/CGI/#distribution">Distribution 
  information</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#book">The CGI.pm Book</A> 

  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#y2000">CGI.pm and the 
  Year 2000 Problem</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#bugs">Bug Reporting and 
  Support</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#new">What's new?</A> 
</LI></MENU>
<HR>

<H2><A name=download>Downloads</A></H2>
<UL>
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.tar.gz">Download gzip tar 
  archive (Unix)</A></STRONG> 
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.zip">Download pkzip 
  archive (Windows)</A></STRONG> 
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.sit">Download sit archive 
  (Macintosh)</A></STRONG> 
  <LI><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm">Download 
  just the CGI module (uncompressed)</A></STRONG> 
  <LI><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/old">Archive of 
  Old Versions</A></STRONG> </LI></UL>
<P>
<H3><FONT color=red>CGI.pm Version 3.01</FONT></H3>Version 3.0 of CGI.pm 
provides a modularized design and significant performance enhancements, courtesy 
David James. Please try and report any bugs or misfeatures to <A 
href="mailto:lstein@cshl.org">me</A>. 
<UL>
  <LI><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm-3.01.tar.gz">Download 
  3.01</A> </LI></UL>
<P>
<H2><A name=installation>Installation</A></H2>
<UL>
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.tar.gz">Download gzip tar 
  archive (Unix)</A></STRONG> 
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.zip">Download pkzip 
  archive (Windows)</A></STRONG> 
  <LI><STRONG><A 
  href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.sit">Download sit archive 
  (Macintosh)</A></STRONG> 
  <LI><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm">Download 
  just the CGI module (uncompressed)</A></STRONG> </LI></UL>
<P>The current version of the software can always be downloaded from the master 
copy of this document maintained at <A 
href="http://stein.cshl.org/WWW/software/CGI/">http://stein.cshl.org/WWW/software/CGI/</A>. 

<P>This package requires perl 5.004 or higher. Earlier versions of Perl may 
work, but CGI.pm has not been tested with them. If you're really stuck, edit the 
source code to remove the line that says "require 5.004", but don't be surprised 
if you run into problems. 
<P>If you are using a Unix system, you should have perl do the installation for 
you. Move to the directory containing CGI.pm and type the following commands: <PRE>   % perl Makefile.PL
   % make
   % make install
</PRE>You may need to be root to do the last step. 
<P>This will create two new files in your Perl library. <B>CGI.pm</B> is the 
main library file. <B>Carp.pm</B> (in the subdirectory "CGI") contains some 
optional utility routines for writing nicely formatted error messages into your 
server logs. See the Carp.pm man page for more details. 
<P><STRONG>If you get error messages when you try to install</STRONG>, then you 
are either: 
<OL>
  <LI>Running a Windows NT or Macintosh port of Perl that doesn't have make or 
  the MakeMaker program built into it. 
  <LI>Have an old version of Perl. Upgrade to 5.004 or higher. </LI></OL>In the 
former case don't panic. Here's a recipe that will work (commands are given in 
MS-DOS/Windows form): <PRE>  &gt; cd CGI.pm-2.73
  &gt; copy CGI.pm C:\Perl\lib
  &gt; mkdir C:\Perl\lib\CGI
  &gt; copy CGI\*.pm C:\Perl\lib\CGI
</PRE>Modify this recipe if your Perl library has a different location. 
<P>For Macintosh users, just drag the file named CGI.pm into the folder where 
your other Perl .pm files are stored. Also drag the subfolder named "CGI". 
<P><STRONG>If you do not have sufficient privileges to install into 
/usr/local/lib/perl5</STRONG>, you can still use CGI.pm. Modify the installation 
recipe as follows: <PRE>   % perl Makefile.PL INSTALLDIRS=site INSTALLSITELIB=/home/your/private/dir
   % make
   % make install
</PRE>Replace <CITE>/home/your/private/dir</CITE> with the full path to the 
directory you want the library placed in. Now preface your CGI scripts with a 
preamble something like the following: 
<BLOCKQUOTE><PRE>use lib '/home/your/private/dir';
use CGI;
</PRE></BLOCKQUOTE>Be sure to replace /home/your/private/dir with the true 
location of CGI.pm. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#non_unix">Notes on using 
CGI.pm in NT and other non-Unix platforms</A> 
<HR>

<H2><A name=functionvsoo>Function-Oriented vs Object-Oriented Use</A></H2>CGI.pm 
can be used in two distinct modes called <CITE>function-oriented</CITE> and 
<CITE>object-oriented</CITE>. In the function-oriented mode, you first import 
CGI functions into your script's namespace, then call these functions directly. 
A simple function-oriented script looks like this: 
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl
use CGI qw/:standard/;
print header(),
      start_html(-title=&gt;'Wow!'),
      h1('Wow!'),
      'Look Ma, no hands!',
      end_html();
</PRE></BLOCKQUOTE>The <CITE>use</CITE> operator loads the CGI.pm definitions 
and imports the ":standard" set of function definitions. We then make calls to 
various functions such as <CITE>header()</CITE>, to generate the HTTP header, 
<CITE>start_html()</CITE>, to produce the top part of an HTML document, 
<CITE>h1()</CITE> to produce a level one header, and so forth. 
<P>In addition to the standard set, there are many optional sets of less 
frequently used CGI functions. See <A 
href="http://stein.cshl.org/WWW/software/CGI/#import">Importing CGI Methods</A> 
for full details. 
<P>In the object-oriented mode, you <CITE>use CGI;</CITE> without specifying any 
functions or function sets to import. In this case, you communicate with CGI.pm 
via a CGI object. The object is created by a call to <CITE>CGI::new()</CITE> and 
encapsulates all the state information about the current CGI transaction, such 
as values of the CGI parameters passed to your script. Although more verbose, 
this coding style has the advantage of allowing you to create multiple CGI 
objects, save their state to disk or to a database, and otherwise manipulate 
them to achieve neat effects. 
<P>The same script written using the object-oriented style looks like this: 
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl
use CGI;
$q = new CGI;
print $q-&gt;header(),
      $q-&gt;start_html(-title=&gt;'Wow!'),
      $q-&gt;h1('Wow!'),
      'Look Ma, no hands!',
      $q-&gt;end_html();
</PRE></BLOCKQUOTE>The object-oriented mode also has the advantage of consuming 
somewhat less memory than the function-oriented coding style. This may be of 
value to users of persistent Perl interpreters such as <A 
href="http://perl.apache.org/">mod_perl</A>. 
<P>Many of the code examples below show the object-oriented coding style. 
Mentally translate them into the function-oriented style if you prefer. 
<H2><A name=query>Creating a new CGI object</A></H2>The most basic use of CGI.pm 
is to get at the query parameters submitted to your script. To create a new CGI 
object that contains the parameters passed to your script, put the following at 
the top of your perl CGI programs: <PRE>    use CGI;
    $query = new CGI;
</PRE>In the object-oriented world of Perl 5, this code calls the new() method 
of the CGI class and stores a new CGI object into the variable named $query. The 
new() method does all the dirty work of parsing the script parameters and 
environment variables and stores its results in the new object. You'll now make 
method calls with this object to get at the parameters, generate form elements, 
and do other useful things. 
<P>An alternative form of the new() method allows you to read script parameters 
from a previously-opened file handle: <PRE>    $query = new CGI(FILEHANDLE)
</PRE>The filehandle can contain a URL-encoded query string, or can be a series 
of newline delimited TAG=VALUE pairs. This is compatible with the save() method. 
This lets you save the state of a CGI script to a file and reload it later. It's 
also possible to save the contents of several query objects to the same file, 
either within a single script or over a period of time. You can then reload the 
multiple records into an array of query objects with something like this: 
<BLOCKQUOTE><PRE>open (IN,"test.in") || die;
while (!eof(IN)) {
    my $q = new CGI(IN);
    push(@queries,$q);
}
</PRE></BLOCKQUOTE>You can make simple databases this way, or create a 
guestbook. If you're a Perl purist, you can pass a reference to the filehandle 
glob instead of the filehandle name. This is the "official" way to pass 
filehandles in Perl5: 
<BLOCKQUOTE><PRE>    my $q = new CGI(\*IN);
</PRE></BLOCKQUOTE>(If you don't know what I'm talking about, then you're not a 
Perl purist and you needn't worry about it.) 
<P>If you are using the function-oriented interface and want to initialize CGI 
state from a file handle, the way to do this is with 
<CITE>restore_parameters()</CITE>. This will (re)initialize the default CGI 
object from the indicated file handle. 
<BLOCKQUOTE><PRE>open (IN,"test.in") || die;
restore_parameters(IN);
close IN;
</PRE></BLOCKQUOTE>
<P>You can initialize a CGI object from an associative-array reference. Values 
can be either single- or multivalued: 
<BLOCKQUOTE><PRE>$query = new CGI({'dinosaur'=&gt;'barney',
                  'song'=&gt;'I love you',
                  'friends'=&gt;[qw/Jessica George Nancy/]});
</PRE></BLOCKQUOTE>You can initialize a CGI object by passing a URL-style query 
string to the new() method like this: 
<BLOCKQUOTE><PRE>$query = new CGI('dinosaur=barney&amp;color=purple');
</PRE></BLOCKQUOTE>Or you can clone a CGI object from an existing one. The 
parameter lists of the clone will be identical, but other fields, such as 
autoescaping, are not: 
<BLOCKQUOTE><PRE>$old_query = new CGI;
$new_query = new CGI($old_query);
</PRE></BLOCKQUOTE>
<P>This form also allows you to create a CGI object that is initially empty: 
<BLOCKQUOTE><PRE>$empty_query = new CGI('');
</PRE></BLOCKQUOTE>See <A 
href="http://stein.cshl.org/WWW/software/CGI/#advanced">advanced techniques</A> 
for more information. 
<H3><A name=keywords>Fetching A List Of Keywords From The Query</A></H3><PRE>    @keywords = $query-&gt;keywords
</PRE>If the script was invoked as the result of an &lt;ISINDEX&gt; search, the 
parsed keywords can be obtained with the keywords() method. This method will 
return the keywords as a perl array. 
<H3><A name=parameters>Fetching The Names Of All The Parameters Passed To Your 
Script</A></H3><PRE>    @names = $query-&gt;param </PRE>If the script was invoked with a 
parameter list (e.g. "name1=value1&amp;name2=value2&amp;name3=value3"), the 
param() method will return the parameter names as a list. For backwards 
compatibility if the script was invoked as an &lt;ISINDEX&gt; script and 
contains a string without ampersands (e.g. "value1+value2+value3") , there will 
be a single parameter named "keywords" containing the "+"-delimited keywords. 
<H3><A name=values>Fetching The Value(s) Of A Named Parameter</A></H3><PRE>   @values = $query-&gt;param('foo');
             -or-
   $value = $query-&gt;param('foo');
</PRE>Pass the param() method a single argument to fetch the value of the named 
parameter. If the parameter is multivalued (e.g. from multiple selections in a 
scrolling list), you can ask to receive an array. Otherwise the method will 
return a single value. 
<P>If a value is not given in the query string, as in the queries 
"name1=&amp;name2=" or "name1&amp;name2", it will be returned as an empty string 
(not undef). This feature is new in 2.63, and was introduced to avoid multiple 
"undefined value" warnings when running with the -w switch. 
<H3><A name=setting>Setting The Value(s) Of A Named Parameter</A></H3><PRE>   $query-&gt;param('foo','an','array','of','values');
                   -or-
   $query-&gt;param(-name=&gt;'foo',-values=&gt;['an','array','of','values']);
</PRE>This sets the value for the named parameter 'foo' to one or more values. 
These values will be used to initialize form elements, if you so desire. Note 
that this is the one way to forcibly change the value of a form field after it 
has previously been set. 
<P>The second example shows an alternative "named parameter" style of function 
call that is accepted by most of the CGI methods. See <A 
href="http://stein.cshl.org/WWW/software/CGI/#named_param">Calling CGI functions 
that Take Multiple Arguments</A> for an explanation of this style. 
<H3><A name=append>Appending a Parameter</A></H3><PRE>   $query-&gt;append(-name=&gt;'foo',-values=&gt;['yet','more','values']);
</PRE>This adds a value or list of values to the named parameter. The values are 
appended to the end of the parameter if it already exists. Otherwise the 
parameter is created. 
<H3><A name=deleting>Deleting a Named Parameter Entirely</A></H3><PRE>   $query-&gt;delete('foo');
</PRE>This deletes a named parameter entirely. This is useful when you want to 
reset the value of the parameter so that it isn't passed down between 
invocations of the script. 
<H3><A name=deleting_all>Deleting all Parameters</A></H3><PRE>   $query-&gt;delete_all();
</PRE>This deletes all the parameters and leaves you with an empty CGI object. 
This may be useful to restore all the defaults produced by the form element 
generating methods. 
<H3><A name=importing>Importing parameters into a namespace</A></H3><PRE>   $query-&gt;import_names('R');
   print "Your name is $R::name\n"
   print "Your favorite colors are @R::colors\n";
</PRE>This imports all parameters into the given name space. For example, if 
there were parameters named 'foo1', 'foo2' and 'foo3', after executing 
<CODE>$query-&gt;import_names('R')</CODE>, the variables <CODE>@R::foo1, 
$R::foo1, @R::foo2, $R::foo2,</CODE> etc. would conveniently spring into 
existence. Since CGI has no way of knowing whether you expect a multi- or 
single-valued parameter, it creates two variables for each parameter. One is an 
array, and contains all the values, and the other is a scalar containing the 
first member of the array. Use whichever one is appropriate. For keyword 
(a+b+c+d) lists, the variable @R::keywords will be created. 
<P>If you don't specify a name space, this method assumes namespace "Q". 
<P>An optional second argument to <B>import_names</B>, if present and non-zero, 
will delete the contents of the namespace before loading it. This may be useful 
for environments like mod_perl in which the script does not exit after 
processing a request. 
<P><STRONG>Warning</STRONG>: do not import into namespace 'main'. This 
represents a major security risk, as evil people could then use this feature to 
redefine central variables such as @INC. CGI.pm will exit with an error if you 
try to do this. 
<P>
<H3><A name=param_fetch>Direct Access to the Parameter List</A></H3>
<BLOCKQUOTE><PRE>$q-&gt;param_fetch('address')-&gt;[1] = '1313 Mockingbird Lane';
unshift @{$q-&gt;param_fetch(-name=&gt;'address')},'George Munster';
</PRE></BLOCKQUOTE>If you need access to the parameter list in a way that isn't 
covered by the methods above, you can obtain a direct reference to it by calling 
the <B>param_fetch()</B> method with the name of the parameter you want. This 
will return an array reference to the named parameters, which you then can 
manipulate in any way you like. 
<P>You may call <B>param_fetch()</B> with the name of the CGI parameter, or with 
the <B>-name</B> argument, which has the same meaning as elsewhere. 
<H3>Fetching the Parameter List as a Hash</H3>
<BLOCKQUOTE><PRE>$params = $q-&gt;Vars;
print $params-&gt;{'address'};
@foo = split("\0",$params-&gt;{'foo'});
%params = $q-&gt;Vars;

use CGI ':cgi-lib';
$params = Vars;
</PRE></BLOCKQUOTE>
<P>Many people want to fetch the entire parameter list as a hash in which the 
keys are the names of the CGI parameters, and the values are the parameters' 
values. The <B>Vars()</B> method does this. Called in a scalar context, it 
returns the parameter list as a tied hash reference. Changing a key changes the 
value of the parameter in the underlying CGI parameter list. Called in an array 
context, it returns the parameter list as an ordinary hash. This allows you to 
read the contents of the parameter list, but not to change it. 
<P>When using this, the thing you must watch out for are multivalued CGI 
parameters. Because a hash cannot distinguish between scalar and array context, 
multivalued parameters will be returned as a packed string, separated by the 
"\0" (null) character. You must split this packed string in order to get at the 
individual values. This is the convention introduced long ago by Steve Brenner 
in his cgi-lib.pl module for Perl version 4. 
<P>If you wish to use <B>Vars()</B> as a function, import the <I>:cgi-lib</I> 
set of function calls (also see the section on <A 
href="http://stein.cshl.org/WWW/software/CGI/#migrating">CGI-LIB 
compatibility</A>). 
<H3><A name=errors>RETRIEVING CGI ERRORS</A></H3>
<P>Errors can occur while processing user input, particularly when processing 
uploaded files. When these errors occur, CGI will stop processing and return an 
empty parameter list. You can test for the existence and nature of errors using 
the <STRONG>cgi_error()</STRONG> function. The error messages are formatted as 
HTTP status codes. You can either incorporate the error text into an HTML page, 
or use it as the value of the HTTP status: <PRE>    my $error = $q-&gt;cgi_error;
    if ($error) {
	print $q-&gt;header(-status=&gt;$error),
	      $q-&gt;start_html('Problems'),
              $q-&gt;h2('Request not processed'),
	      $q-&gt;strong($error);
        exit 0;
    }
</PRE>
<P>When using the function-oriented interface (see the next section), errors may 
only occur the first time you call <STRONG>param()</STRONG>. Be prepared for 
this! <A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=saving>Saving the Current State of a Form</A></H2>
<H3>Saving the State to a File</H3><PRE>   $query-&gt;save(FILEHANDLE)
</PRE>This writes the current query out to the file handle of your choice. The 
file handle must already be open and be writable, but other than that it can 
point to a file, a socket, a pipe, or whatever. The contents of the form are 
written out as TAG=VALUE pairs, which can be reloaded with the new() method at 
some later time. You can write out multiple queries to the same file and later 
read them into query objects one by one. 
<P>If you wish to use this method from the function-oriented (non-OO) interface, 
the exported name for this method is <CITE>save_parameters()</CITE>. See <A 
href="http://stein.cshl.org/WWW/software/CGI/#advanced">advanced techniques</A> 
for more information. 
<H3><A name=self_referencing>Saving the State in a Self-Referencing URL</A></H3><PRE>   $my_url=$query-&gt;self_url
</PRE>This call returns a URL that, when selected, reinvokes this script with 
all its state information intact. This is most useful when you want to jump 
around within a script-generated document using internal anchors, but don't want 
to disrupt the current contents of the form(s). See <A 
href="http://stein.cshl.org/WWW/software/CGI/#advanced">advanced techniques</A> 
for an example. 
<P>If you'd like to get the URL without the entire query string appended to it, 
use the <CODE>url()</CODE> method: <PRE>   $my_self=$query-&gt;url
</PRE>
<H3>Obtaining the Script's URL</H3><PRE>    $full_url      = $query-&gt;url();
    $full_url      = $query-&gt;url(-full=&gt;1);  #alternative syntax
    $relative_url  = $query-&gt;url(-relative=&gt;1);
    $absolute_url  = $query-&gt;url(-absolute=&gt;1);
    $url_with_path = $query-&gt;url(-path_info=&gt;1);
    $url_with_path_and_query = $query-&gt;url(-path_info=&gt;1,-query=&gt;1);
</PRE><CODE>url()</CODE> returns the script's URL in a variety of formats. 
Called without any arguments, it returns the full form of the URL, including 
host name and port number <PRE>http://your.host.com/path/to/script.cgi
</PRE>You can modify this format with the following named arguments: 
<DL>
  <DT><STRONG>-absolute</STRONG> 
  <DD>If true, produce an absolute URL, e.g. <PRE>/path/to/script.cgi
      </PRE>
  <P></P>
  <DT><STRONG>-relative</STRONG> 
  <DD>Produce a relative URL. This is useful if you want to reinvoke your script 
  with different parameters. For example: <PRE>    script.cgi
</PRE>
  <P></P>
  <DT><STRONG>-full</STRONG> 
  <DD>Produce the full URL, exactly as if called without any arguments. This 
  overrides the -relative and -absolute arguments. 
  <P></P>
  <DT><STRONG>-path</STRONG>,<STRONG>-path_info</STRONG> 
  <DD>Append the additional path information to the URL. This can be combined 
  with -full, -absolute or -relative. -path_info is provided as a synonym. 
  <P></P>
  <DT><STRONG>-query</STRONG> (<STRONG>-query_string</STRONG>) 
  <DD>Append the query string to the URL. This can be combined with -full, 
  -absolute or -relative. -query_string is provided as a synonym. </DD></DL>
<H3>Mixing POST and URL Parameters</H3><PRE>   $color = $query-&gt;url_param('color');
</PRE>It is possible for a script to receive CGI parameters in the URL as well 
as in the fill-out form by creating a form that POSTs to a URL containing a 
query string (a "?" mark followed by arguments). The <B>param()</B> method will 
always return the contents of the POSTed fill-out form, ignoring the URL's query 
string. To retrieve URL parameters, call the <B>url_param()</B> method. Use it 
in the same way as <B>param()</B>. The main difference is that it allows you to 
read the parameters, but not set them. 
<P>Under no circumstances will the contents of the URL query string interfere 
with similarly-named CGI parameters in POSTed forms. If you try to mix a URL 
query string with a form submitted with the GET method, the results will not be 
what you expect. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H3><A name=named_param>Calling CGI Functions that Take Multiple Arguments</A> 
</H3>In versions of CGI.pm prior to 2.0, it could get difficult to remember the 
proper order of arguments in CGI function calls that accepted five or six 
different arguments. As of 2.0, there's a better way to pass arguments to the 
various CGI functions. In this style, you pass a series of name=&gt;argument 
pairs, like this: <PRE>   $field = $query-&gt;radio_group(-name=&gt;'OS',
                                -values=&gt;[Unix,Windows,Macintosh],
                                -default=&gt;'Unix');
</PRE>The advantages of this style are that you don't have to remember the exact 
order of the arguments, and if you leave out a parameter, it will usually 
default to some reasonable value. If you provide a parameter that the method 
doesn't recognize, it will usually do something useful with it, such as 
incorporating it into the HTML tag as an attribute. For example if Netscape 
decides next week to add a new JUSTIFICATION parameter to the text field tags, 
you can start using the feature without waiting for a new version of CGI.pm: <PRE>   $field = $query-&gt;textfield(-name=&gt;'State',
                              -default=&gt;'gaseous',
                              -justification=&gt;'RIGHT');
</PRE>This will result in an HTML tag that looks like this: <PRE>   &lt;INPUT TYPE="textfield" NAME="State" VALUE="gaseous"
          JUSTIFICATION="RIGHT"&gt;
</PRE>Parameter names are case insensitive: you can use -name, or -Name or 
-NAME. Actually, CGI.pm only looks for a hyphen in the first parameter. So you 
can leave it off subsequent parameters if you like. Something to be wary of is 
the potential that a string constant like "values" will collide with a keyword 
(and in fact it does!) While Perl usually figures out when you're referring to a 
function and when you're referring to a string, you probably should put 
quotation marks around all string constants just to play it safe. 
<P>HTML/HTTP parameters that contain internal hyphens, such as 
<I>-Content-language</I> can be passed by putting quotes around them, or by 
using an underscore for the second hyphen, e.g. <CITE>-Content_language</CITE>. 
<P>The fact that you must use curly {} braces around the attributes passed to 
functions that create simple HTML tags but don't use them around the arguments 
passed to all other functions has many people, including myself, confused. As of 
2.37b7, the syntax is extended to allow you to use curly braces for all function 
calls: <PRE>   $field = $query-&gt;radio_group({-name=&gt;'OS',
                                -values=&gt;[Unix,Windows,Macintosh],
                                -default=&gt;'Unix'});
</PRE><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=header>Creating the HTTP Header</A> </H2>
<H3><A name=standard_header>Creating the Standard Header for a Virtual 
Document</A> </H3><PRE>   print $query-&gt;header('image/gif');
</PRE>This prints out the required HTTP Content-type: header and the requisite 
blank line beneath it. If no parameter is specified, it will default to 
'text/html'. 
<P>An extended form of this method allows you to specify a status code and a 
message to pass back to the browser: <PRE>   print $query-&gt;header(-type=&gt;'image/gif',
                        -status=&gt;'204 No Response');
</PRE>This presents the browser with a status code of 204 (No response). 
Properly-behaved browsers will take no action, simply remaining on the current 
page. (This is appropriate for a script that does some processing but doesn't 
need to display any results, or for a script called when a user clicks on an 
empty part of a clickable image map.) 
<P>Several other named parameters are recognized. Here's a contrived example 
that uses them all: <PRE>   print $query-&gt;header(-type=&gt;'image/gif',
                        -status=&gt;'402 Payment Required',
                        -expires=&gt;'+3d',
                        -cookie=&gt;$my_cookie,
                        -charset=&gt;'UTF-7',
                        -attachment=&gt;'foo.gif',
                        -Cost=&gt;'$0.02');
</PRE>
<H4>-expires</H4>Some browsers, such as Internet Explorer, cache the output of 
CGI scripts. Others, such as Netscape Navigator do not. This leads to annoying 
and inconsistent behavior when going from one browser to another. You can force 
the behavior to be consistent by using the <STRONG>-expires</STRONG> parameter. 
When you specify an absolute or relative expiration interval with this 
parameter, browsers and proxy servers will cache the script's output until the 
indicated expiration date. The following forms are all valid for the 
<STRONG>-expires</STRONG> field: <PRE>	+30s                              30 seconds from now
	+10m                              ten minutes from now
	+1h	                          one hour from now
        -1d                               yesterday (i.e. "ASAP!")
	now                               immediately
	+3M                               in three months
        +10y                              in ten years time
	Thu, 25-Apr-1999 00:40:33 GMT     at the indicated time &amp; date
</PRE>When you use <STRONG>-expires</STRONG>, the script also generates a 
correct time stamp for the generated document to ensure that your clock and the 
browser's clock agree. This allows you to create documents that are reliably 
cached for short periods of time. 
<P><STRONG>CGI::expires()</STRONG> is the static function call used internally 
that turns relative time intervals into HTTP dates. You can call it directly if 
you wish. 
<H4>-cookie</H4>The <STRONG>-cookie</STRONG> parameter generates a header that 
tells Netscape browsers to return a "magic cookie" during all subsequent 
transactions with your script. HTTP cookies have a special format that includes 
interesting attributes such as expiration time. Use the <A 
href="http://stein.cshl.org/WWW/software/CGI/#cookies">cookie()</A> method to 
create and retrieve session cookies. The value of this parameter can be either a 
scalar value or an array reference. You can use the latter to generate multiple 
cookies. (You can use the alias <STRONG>-cookies</STRONG> for readability.) 
<H4>-nph</H4>The <STRONG>-nph</STRONG> parameter, if set to a non-zero value, 
will generate a valid header for use in no-parsed-header scripts. For example: 
<BLOCKQUOTE><PRE>print $query-&gt;header(-nph=&gt;1,
                        -status=&gt;'200 OK',
                        -type=&gt;'text/html');
</PRE></BLOCKQUOTE>You will need to use this if: 
<OL>
  <LI>You are using Microsoft Internet Information Server. 
  <LI>If you need to create unbuffered output, for example for use in a "server 
  push" script. 
  <LI>To take advantage of HTTP extensions not supported by your server. 
</LI></OL>See <A href="http://stein.cshl.org/WWW/software/CGI/#nph">Using NPH 
Scripts</A> for more information. 
<H4>-charset</H4>The <B>-charset</B> parameter can be used to control the 
character set sent to the browser. If not provided, defaults to ISO-8859-1. As a 
side effect, this calls the charset() method to set the behavior for 
escapeHTML(). 
<H4>-attachment</H4>The <B>-attachment</B> parameter can be used to turn the 
page into an attachment. Instead of displaying the page, some browsers will 
prompt the user to save it to disk. The value of the argument is the suggested 
name for the saved file. In order for this to work, you may have to set the 
<B>-type</B> to "application/octet-stream". 
<H4>Other header fields</H4>Any other parameters that you pass to 
<STRONG>header()</STRONG> will be turned into correctly formatted HTTP header 
fields, even if they aren't called for in the current HTTP spec. For example, 
the example that appears a few paragraphs above creates a field that looks like 
this: <PRE>   Cost: $0.02
</PRE>You can use this to take advantage of new HTTP header fields without 
waiting for the next release of CGI.pm. 
<H3><A name=redirect>Creating the Header for a Redirection Request</A></H3><PRE>   print $query-&gt;redirect('http://somewhere.else/in/the/world');
</PRE>This generates a redirection request for the remote browser. It will 
immediately go to the indicated URL. You should exit soon after this. Nothing 
else will be displayed. 
<P>You can add your own headers to this as in the header() method. 
<P>You should always use absolute or full URLs in redirection requests. Relative 
URLs will <STRONG>not</STRONG> work correctly. 
<P>An alternative syntax for <CODE>redirect()</CODE> is: 
<BLOCKQUOTE><PRE>print $query-&gt;redirect(-location=&gt;'http://somewhere.else/',
                          -nph=&gt;1);
</PRE></BLOCKQUOTE>The <STRONG>-location</STRONG> parameter gives the 
destination URL. You may also use <STRONG>-uri</STRONG> or <STRONG>-url</STRONG> 
if you prefer. 
<P>The <STRONG>-nph</STRONG> parameter, if non-zero tells CGI.pm that this 
script is running as a no-parsed-header script. See <A 
href="http://stein.cshl.org/WWW/software/CGI/#nph">Using NPH Scripts</A> for 
more information. 
<P>The <STRONG>-method</STRONG> parameter tells the browser what method to use 
for redirection. This is handy if, for example, your script was called from a 
fill-out form POST operation, but you want to redirect the browser to a static 
page that requires a GET. 
<P>All other parameters recognized by the <TT>header()</TT> method are also 
valid in <TT>redirect</TT>. <A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<HR>

<H2><A name=html>HTML Shortcuts</A></H2>
<H3>Creating an HTML Header</H3><PRE>   <EM>named parameter style</EM>
   print $query-&gt;start_html(-title=&gt;'Secrets of the Pyramids',
                            -author=&gt;'fred@capricorn.org',
                            -base=&gt;'true',
			    -meta=&gt;{'keywords'=&gt;'pharoah secret mummy',
                                    'copyright'=&gt;'copyright 1996 King Tut'},
			    -style=&gt;{'src'=&gt;'/styles/style1.css'},
                            -dtd=&gt;1,
                            -BGCOLOR=&gt;'blue');

   <EM>old style</EM>
   print $query-&gt;start_html('Secrets of the Pyramids',
                            'fred@capricorn.org','true');
</PRE>This will return a canned HTML header and the opening &lt;BODY&gt; tag. 
All parameters are optional: 
<UL>
  <LI>The title (<STRONG>-title</STRONG>) 
  <LI>The author's e-mail address (will create a &lt;LINK REV="MADE"&gt; tag if 
  present (<STRONG>-author</STRONG>) 
  <LI>A true flag if you want to include a &lt;BASE&gt; tag in the header 
  (<STRONG>-base</STRONG>). This helps resolve relative addresses to absolute 
  ones when the document is moved, but makes the document hierarchy 
  non-portable. Use with care! 
  <LI>A <STRONG>-xbase</STRONG> parameter, if you want to include a &lt;BASE&gt; 
  tag that points to some external location. Example: <PRE>      print $query-&gt;start_html(-title=&gt;'Secrets of the Pyramids',
                               -xbase=&gt;'http://www.nile.eg/pyramid.html');
      </PRE>
  <LI>A <STRONG>-target</STRONG> parameter, if you want to have all links and 
  fill out forms on the page go to a different frame. Example: <PRE>      print $query-&gt;start_html(-title=&gt;'Secrets of the Pyramids',
                               -target=&gt;'answer_frame');
      </PRE><STRONG>-target</STRONG> can be used with either 
  <STRONG>-xbase</STRONG> or <STRONG>-base</STRONG>. 
  <LI>A <STRONG>-meta</STRONG> parameter to define one or more &lt;META&gt; 
  tags. Pass this parameter a reference to an associative array containing 
  key/value pairs. Each pair becomes a &lt;META&gt; tag in a format similar to 
  this one. 
  <BLOCKQUOTE><PRE>      &lt;META NAME="keywords" CONTENT="pharoah secret mummy"&gt;
      &lt;META NAME="description" CONTENT="copyright 1996 King Tut"&gt;
      </PRE></BLOCKQUOTE>To create an HTTP-EQUIV tag, use the <B>-head</B> 
  argument as described below. 
  <LI>The <B>-encoding</B> argument can be used to specify the character set for 
  XHTML. It defaults to iso-8859-1 if not specified. 
  <LI>A <STRONG>-lang</STRONG>&gt; argument is used to incorporate a language 
  attribute into the &lt;HTM&gt;&gt; tag. The default if not specified is 
  "en-US" for US English. For example: 
  <BLOCKQUOTE><PRE>    print $q-&gt;start_html(-lang=&gt;'fr-CA');
</PRE></BLOCKQUOTE>
  <LI>A <STRONG>-dtd</STRONG> parameter to make start_html() generate an SGML 
  document type definition for the document. This is used by SGML editors and 
  high-end Web publishing systems to determine the type of the document. 
  However, it breaks some browsers, in particular AOL's. The value of this 
  parameter can be one of: 
  <OL>
    <LI>A valid DTD (see <A 
    href="http://ugweb.cs.ualberta.ca/~gerald/validate/lib/catalog">http://ugweb.cs.ualberta.ca/~gerald/validate/lib/catalog</A> 
    for a list). Example: <PRE>-dtd=&gt;'-//W3C//DTD HTML 3.2//EN'</PRE>
    <LI>A true value that does not begin with "-//", in which case you will get 
    the standard default DTD (valid for HTML 2.0). </LI></OL>You can change the 
  default DTD by calling <STRONG>default_dtd()</STRONG> with the preferred 
  value. 
  <LI>A <STRONG>-style</STRONG> parameter to define a cascading stylesheet. More 
  information on this can be found in <A 
  href="http://stein.cshl.org/WWW/software/CGI/#stylesheets">Limited Support for 
  Cascading Style Sheets</A> 
  <LI>A <STRONG>-head</STRONG> parameter to define other arbitrary elements of 
  the &lt;HEAD&gt; section. For example: <PRE>      print start_html(-head=&gt;Link({-rel=&gt;'next',
                       -href=&gt;'http://www.capricorn.com/s2.html'}));

      </PRE>or even <PRE>      print start_html(-head=&gt;[ Link({-rel=&gt;'next',
			                 -href=&gt;'http://www.capricorn.com/s2.html'}),
			           Link({-rel=&gt;'previous',
				         -href=&gt;'http://www.capricorn.com/s1.html'})
			      ]
		      );
      </PRE>To create an HTTP-EQUIV tag, use something like this: <PRE>      print start_html(-head=&gt;meta({-http_equiv=&gt;'Content-Type',
                                       -content=&gt;'text/html'}))
      </PRE>
  <LI>A <STRONG>-script</STRONG> parameter to define Netscape <A 
  href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
  functions to incorporate into the HTML page. This is the preferred way to 
  define a library of JavaScript functions that will be called from elsewhere 
  within the page. CGI.pm will attempt to format the JavaScript code in such a 
  way that non-Netscape browsers won't try to display the JavaScript code. 
  Unfortunately some browsers get confused nevertheless. Here's an example of 
  how to create a JavaScript library and incorporating it into the HTML code 
  header: <PRE>      $query = new CGI;
      print $query-&gt;header;
      
      $JSCRIPT=&lt;&lt;END;
      // Ask a silly question
      function riddle_me_this() {
         var r = prompt("What walks on four legs in the morning, " +
                       "two legs in the afternoon, " +
                       "and three legs in the evening?");
         response(r);
      }
      // Get a silly answer
      function response(answer) {
         if (answer == "man")
            alert("Right you are!");
         else
            alert("Wrong!  Guess again.");
      }
      END
      
      print $query-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                               -script=&gt;$JSCRIPT);
      </PRE>Netscape 3.0 and higher allows you to place the JavaScript code in 
  an external document and refer to it by URL. This allows you to keep the 
  JavaScript code in a file or CGI script rather than cluttering up each page 
  with the source. Netscape 3.X-4.X and Internet Explorer 3.X-4.X also recognize 
  a "language" parameter that allows you to use other languages, such as 
  VBScript and PerlScript (yes indeed!) To use these attributes pass a HASH 
  reference in the <STRONG>-script</STRONG> parameter containing one or more of 
  the keys <STRONG>language</STRONG>, <STRONG>src</STRONG>, or 
  <STRONG>code</STRONG>. Here's how to refer to an external script URL: <PRE>      print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
			   -script=&gt;{-language=&gt;'JavaScript',
                                   -src=&gt;'/javascript/sphinx.js'}
                              );
     </PRE>Here's how to refer to scripting code incorporated directly into 
  the page: <PRE>
     print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                          -script=&gt;{-language=&gt;'PerlScript',
                                    -code=&gt;'print "hello world!\n;"'}
                             );
     </PRE>A final feature allows you to incorporate multiple &lt;SCRIPT&gt; 
  sections into the header. Just pass the list of script sections as an array 
  reference. This allows you to specify different source files for different 
  dialects of JavaScript. Example: <PRE>     print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                          -script=&gt;[
                                    { -language =&gt; 'JavaScript1.0',
                                      -src      =&gt; '/javascript/utilities10.js'
                                    },
                                    { -language =&gt; 'JavaScript1.1',
                                      -src      =&gt; '/javascript/utilities11.js'
                                    },
                                    { -language =&gt; 'JavaScript1.2',
                                      -src      =&gt; '/javascript/utilities12.js'
                                    },
                                    { -language =&gt; 'JavaScript28.2',
                                      -src      =&gt; '/javascript/utilities219.js'
                                    }
                                 ]
                             );
     </PRE>(If this looks a bit extreme, take my advice and stick with 
  straight CGI scripting.) 
  <P></P>
  <LI>A <STRONG>-noScript</STRONG> parameter to pass some HTML that will be 
  displayed in browsers that do not have JavaScript (or have JavaScript turned 
  off). 
  <LI><STRONG>-onLoad</STRONG> and <STRONG>-onUnload</STRONG> parameters to 
  register JavaScript event handlers to be executed when the page generated by 
  your script is opened and closed respectively. Example: <PRE>      print $query-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                                  -script=&gt;$JSCRIPT,
                                  -onLoad=&gt;'riddle_me_this()');
      </PRE>See <A 
  href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScripting</A> 
  for more details. 
  <LI>Any additional attributes you want to incorporate into the &lt;BODY&gt; 
  tag (as many as you like). This is a good way to incorporate other Netscape 
  extensions, such as background color and wallpaper pattern. (The example above 
  sets the page background to a vibrant blue.) You can use this feature to take 
  advantage of new HTML features without waiting for a CGI.pm release. </LI></UL>
<H3>Ending an HTML Document</H3><PRE>  print $query-&gt;end_html
</PRE>This ends an HTML document by printing the &lt;/BODY&gt; &lt;/HTML&gt; 
tags. 
<H3>Other HTML Tags</H3>CGI.pm provides shortcut methods for many other HTML 
tags. All HTML2 tags and the Netscape extensions are supported, as well as the 
HTML3 and HTML4 tags. Unpaired tags, paired tags, and tags that contain 
attributes are all supported using a simple syntax. 
<P>To see the list of HTML tags that are supported, open up the CGI.pm file and 
look at the functions defined in the %EXPORT_TAGS array. 
<H4>Unpaired Tags</H4>Unpaired tags include &lt;P&gt;, &lt;HR&gt; and 
&lt;BR&gt;. The syntax for creating them is: <PRE>   print $query-&gt;hr;
</PRE>This prints out the text "&lt;hr&gt;". 
<H4>Paired Tags</H4>Paired tags include &lt;EM&gt;, &lt;I&gt; and the like. The 
syntax for creating them is: <PRE>   print $query-&gt;em("What a silly art exhibit!");
</PRE>This prints out the text "&lt;em&gt;What a silly art exhibit!&lt;/em&gt;". 

<P>You can pass as many text arguments as you like: they'll be concatenated 
together with spaces. This allows you to create nested tags easily: <PRE>   print $query-&gt;h3("The",$query-&gt;em("silly"),"art exhibit");
</PRE>This creates the text: <PRE>   &lt;h3&gt;The &lt;em&gt;silly&lt;/em&gt; art exhibit&lt;/h3&gt;
</PRE>
<P>When used in conjunction with the <A 
href="http://stein.cshl.org/WWW/software/CGI/#import">import</A> facility, the 
HTML shortcuts can make CGI scripts easier to read. For example: <PRE>   use CGI qw/:standard/;
   print h1("Road Guide"),
         ol(
          li(a({href=&gt;"start.html"},"The beginning")),
          li(a({href=&gt;"middle.html"},"The middle")),
          li(a({href=&gt;"end.html"},"The end"))
         );
</PRE>
<P>Most HTML tags are represented as lowercase function calls. There are a few 
exceptions: 
<OL>
  <LI>The &lt;tr&gt; tag used to start a new table row conflicts with the perl 
  <CITE>translate</CITE> function <CODE>tr()</CODE>. Use TR() or Tr() instead. 
  <LI>The &lt;param&gt; tag used to pass parameters to an applet conflicts with 
  CGI's own <CODE>param() </CODE>method. Use PARAM() instead. 
  <LI>The &lt;select&gt; tag used to create selection lists conflicts with 
  Perl's select() function. Use <CODE>Select()</CODE> instead. 
  <LI>The &lt;sub&gt; tag used to create subscripts conflicts wit Perl's 
  operator for creating subroutines. Use <CODE>Sub()</CODE> instead. </LI></OL>
<H4>Tags with Attributes</H4>To add attributes to an HTML tag, simply pass a 
reference to an associative array as the first argument. The keys and values of 
the associative array become the names and values of the attributes. For 
example, here's how to generate an &lt;A&gt; anchor link: <PRE>   use CGI qw/:standard/;
   print a({-href=&gt;"bad_art.html"},"Jump to the silly exhibit");

   <I>&lt;A HREF="bad_art.html"&gt;Jump to the silly exhibit&lt;/A&gt;</I>
</PRE>You may dispense with the dashes in front of the attribute names if you 
prefer: <PRE>   print img {src=&gt;'fred.gif',align=&gt;'LEFT'};

   <I>&lt;IMG ALIGN="LEFT" SRC="fred.gif"&gt;</I>
</PRE>Sometimes an HTML tag attribute has no argument. For example, ordered 
lists can be marked as COMPACT, or you wish to specify that a table has a border 
with &lt;TABLE BORDER&gt;. The syntax for this is an argument that that points 
to an undef string: <PRE>   print ol({compact=&gt;undef},li('one'),li('two'),li('three'));
</PRE>Prior to CGI.pm version 2.41, providing an empty ('') string as an 
attribute argument was the same as providing undef. However, this has changed in 
order to accomodate those who want to create tags of the form &lt;IMG 
ALT=""&gt;. The difference is shown in this table: 
<TABLE border=1>
  <TBODY>
  <TR>
    <TH>CODE</TH>
    <TH>RESULT</TH></TR>
  <TR>
    <TD><TT>img({alt=&gt;undef})</TT></TD>
    <TD>&lt;IMG ALT&gt;</TD></TR>
  <TR>
    <TD><TT>img({alt=&gt;''})</TT></TD>
    <TD>&lt;IMT ALT=""&gt;</TD></TR></TBODY></TABLE>
<H4>Distributive HTML Tags and Tables</H4>All HTML tags are distributive. If you 
give them an argument consisting of a <B>reference</B> to a list, the tag will 
be distributed across each element of the list. For example, here's one way to 
make an ordered list: 
<BLOCKQUOTE><PRE>print ul(
        li({-type=&gt;'disc'},['Sneezy','Doc','Sleepy','Happy']);
      );
</PRE></BLOCKQUOTE>This example will result in HTML output that looks like this: 

<BLOCKQUOTE><PRE>&lt;UL&gt;
  &lt;LI TYPE="disc"&gt;Sneezy&lt;/LI&gt;
  &lt;LI TYPE="disc"&gt;Doc&lt;/LI&gt;
  &lt;LI TYPE="disc"&gt;Sleepy&lt;/LI&gt;
  &lt;LI TYPE="disc"&gt;Happy&lt;/LI&gt;
&lt;/UL&gt;
</PRE></BLOCKQUOTE>You can take advantage of this to create HTML tables easily 
and naturally. Here is some code and the HTML it outputs: 
<BLOCKQUOTE><PRE>use CGI qw/:standard :html3/;
print table({-border=&gt;undef},
        caption(strong('When Should You Eat Your Vegetables?')),
        Tr({-align=&gt;CENTER,-valign=&gt;TOP},
        [
           th(['','Breakfast','Lunch','Dinner']),
           th('Tomatoes').td(['no','yes','yes']),
           th('Broccoli').td(['no','no','yes']),
           th('Onions').td(['yes','yes','yes'])
        ]
      )
);
</PRE></BLOCKQUOTE>
<TABLE border=1>
  <CAPTION><STRONG>When Should You Eat Your Vegetables?</STRONG></CAPTION>
  <TBODY>
  <TR vAlign=top align=middle>
    <TH></TH>
    <TH>Breakfast</TH>
    <TH>Lunch</TH>
    <TH>Dinner</TH></TR>
  <TR vAlign=top align=middle>
    <TH>Tomatoes</TH>
    <TD>no</TD>
    <TD>yes</TD>
    <TD>yes</TD></TR>
  <TR vAlign=top align=middle>
    <TH>Broccoli</TH>
    <TD>no</TD>
    <TD>no</TD>
    <TD>yes</TD></TR>
  <TR vAlign=top align=middle>
    <TH>Onions</TH>
    <TD>yes</TD>
    <TD>yes</TD>
    <TD>yes</TD></TR></TBODY></TABLE>
<P>If you want to produce tables programatically, you can do it this way: 
<BLOCKQUOTE><PRE>use CGI qw/:standard :html3/;
@values = (1..5);

@headings = ('N','N'.sup('2'),'N'.sup('3'));
@rows = th(\@headings);
foreach $n (@values) {
   push(@rows,td([$n,$n**2,$n**3]));
}
print table({-border=&gt;undef,-width=&gt;'25%'},
            caption(b('Wow.  I can multiply!')),
            Tr(\@rows)
           );
</PRE></BLOCKQUOTE>
<TABLE width="25%" border=1>
  <CAPTION><B>Wow. I can multiply!</B></CAPTION>
  <TBODY>
  <TR>
    <TH>N</TH>
    <TH>N<SUP>2</SUP></TH>
    <TH>N<SUP>3</SUP></TH></TR>
  <TR>
    <TD>1</TD>
    <TD>1</TD>
    <TD>1</TD></TR>
  <TR>
    <TD>2</TD>
    <TD>4</TD>
    <TD>8</TD></TR>
  <TR>
    <TD>3</TD>
    <TD>9</TD>
    <TD>27</TD></TR>
  <TR>
    <TD>4</TD>
    <TD>16</TD>
    <TD>64</TD></TR>
  <TR>
    <TD>5</TD>
    <TD>25</TD>
    <TD>125</TD></TR></TBODY></TABLE><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<HR>

<H2><A name=forms>Creating Forms</A></H2><EM>General note 1.</EM> The various 
form-creating methods all return strings to the caller. These strings will 
contain the HTML code that will create the requested form element. You are 
responsible for actually printing out these strings. It's set up this way so 
that you can place formatting tags around the form elements. 
<P><A name=overriding><EM>General note 2.</EM> </A>The default values that you 
specify for the forms are only used the <STRONG>first</STRONG> time the script 
is invoked. If there are already values present in the query string, they are 
used, even if blank. 
<P>If you want to change the value of a field from its previous value, you have 
two choices: 
<OL>
  <LI>call the <STRONG>param()</STRONG> method to set it. 
  <LI>use the <B>-override</B> (alias <B>-force</B>) parameter. (This is a new 
  feature in 2.15) This forces the default value to be used, regardless of the 
  previous value of the field: <PRE>       print $query-&gt;textfield(-name=&gt;'favorite_color',
                               -default=&gt;'red',
			       -override=&gt;1);
       </PRE></LI></OL>If you want to reset all fields to their defaults, you 
can: 
<OL>
  <LI>Create a special <VAR>defaults</VAR> button using the 
  <STRONG>defaults()</STRONG> method. 
  <LI>Create a hypertext link that calls your script without any parameters. 
  </LI></OL><EM>General note 3.</EM> You can put multiple forms on the same page 
if you wish. However, be warned that it isn't always easy to preserve state 
information for more than one form at a time. See <A 
href="http://stein.cshl.org/WWW/software/CGI/#advanced">advanced techniques</A> 
for some hints. 
<P><EM>General note 4.</EM> By popular demand, the text and labels that you 
provide for form elements are escaped according to HTML rules. This means that 
you can safely use "&lt;CLICK ME&gt;" as the label for a button. However, this 
behavior may interfere with your ability to incorporate special HTML character 
sequences, such as &amp;Aacute; () into your fields. If you wish to turn off 
automatic escaping, call the <CODE>autoEscape()</CODE> method with a false value 
immediately after creating the CGI object: <PRE>     $query = new CGI;
     $query-&gt;autoEscape(undef);
</PRE>You can turn autoescaping back on at any time with 
<CODE>$query-&gt;autoEscape('yes')</CODE> 
<H3>Form Elements</H3>
<MENU>
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#startform">Opening a 
  form</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#textfield">Text entry 
  fields</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#textarea">Big text entry 
  fields</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#password">Password 
  fields</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#upload">File upload 
  fields</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#menu">Popup menus</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#scrolling_list">Scrolling 
  lists</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#checkbox_group">Checkbox 
  groups</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#checkbox">Individual 
  checkboxes</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#radio">Radio button 
  groups</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#submit">Submission 
  buttons</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#reset">Reset buttons</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#defaults">Reset to 
  defaults button</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#hidden">Hidden fields</A> 

  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#image">Clickable 
  Images</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#button">JavaScript 
  Buttons</A> 
  <LI><A href="http://stein.cshl.org/WWW/software/CGI/#escape">Autoescaping 
  HTML</A> </LI></MENU><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Up to table of 
contents</A> 
<H3><A name=isindex>Creating An Isindex Tag</A></H3><PRE>   print $query-&gt;isindex($action);
</PRE><STRONG>isindex()</STRONG> without any arguments returns an 
&lt;ISINDEX&gt; tag that designates your script as the URL to call. If you want 
the browser to call a different URL to handle the search, pass isindex() the URL 
you want to be called. 
<H3><A name=startform>Starting And Ending A Form</A></H3><PRE>   print $query-&gt;startform($method,$action,$encoding);
     <VAR>...various form stuff...</VAR>
   print $query-&gt;endform;
</PRE><STRONG>startform()</STRONG> will return a &lt;FORM&gt; tag with the 
optional method, action and form encoding that you specify. 
<STRONG>endform()</STRONG> returns a &lt;/FORM&gt; tag. 
<P>The form encoding supports the "file upload" feature of Netscape 2.0 (and 
higher) and Internet Explorer 4.0 (and higher). The form encoding tells the 
browser how to package up the contents of the form in order to transmit it 
across the Internet. There are two types of encoding that you can specify: 
<DL>
  <DT><STRONG>application/x-www-form-urlencoded</STRONG> 
  <DD>This is the type of encoding used by all browsers prior to Netscape 2.0. 
  It is compatible with many CGI scripts and is suitable for short fields 
  containing text data. For your convenience, CGI.pm stores the name of this 
  encoding type in <CODE>$CGI::URL_ENCODED</CODE>. 
  <DT><STRONG>multipart/form-data</STRONG> 
  <DD>This is the newer type of encoding introduced by Netscape 2.0. It is 
  suitable for forms that contain very large fields or that are intended for 
  transferring binary data. Most importantly, it enables the "file upload" 
  feature of Netscape 2.0 forms. For your convenience, CGI.pm stores the name of 
  this encoding type in <CODE>CGI::MULTIPART()</CODE> 
  <P>Forms that use this type of encoding are not easily interpreted by CGI 
  scripts unless they use CGI.pm or another library that knows how to handle 
  them. Unless you are using the file upload feature, there's no particular 
  reason to use this type of encoding. </P></DD></DL>For compatability, the 
startform() method uses the older form of encoding by default. If you want to 
use the newer form of encoding By default, you can call <A 
href="http://stein.cshl.org/WWW/software/CGI/#multipart">start_multipart_form()</A> 
instead of <CODE>startform()</CODE>. 
<P>If you plan to make use of the <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript 
features</A>, you can provide <CODE>startform()</CODE> with the optional 
<CODE>-name</CODE> and/or <CODE>-onSubmit</CODE> parameters. <CODE>-name</CODE> 
has no effect on the display of the form, but can be used to give the form an 
identifier so that it can be manipulated by JavaScript functions. Provide the 
<CODE>-onSubmit</CODE> parameter in order to register some JavaScript code to be 
performed just before the form is submitted. This is useful for checking the 
validity of a form before submitting it. Your JavaScript code should return a 
value of "true" to let Netscape know that it can go ahead and submit the form, 
and "false" to abort the submission. 
<H3><A name=multipart>Starting a Form that Uses the "File Upload" 
Feature</A></H3><PRE>   print $query-&gt;start_multipart_form($method,$action,$encoding);
     <VAR>...various form stuff...</VAR>
   print $query-&gt;endform;
</PRE>This has exactly the same usage as <CODE>startform()</CODE>, but it 
specifies form encoding type <CODE>multipart/form-data</CODE> as the default. 
<H3><A name=textfield>Creating A Text Field</A></H3><PRE>  <EM>Named parameter style</EM>
  print $query-&gt;textfield(-name=&gt;'field_name',
	                    -default=&gt;'starting value',
	                    -size=&gt;50,
	                    -maxlength=&gt;80);

   <EM>Old style</EM>
  print $query-&gt;textfield('foo','starting value',50,80);
</PRE><STRONG>textfield()</STRONG> will return a text input field. 
<UL>
  <LI>The first parameter (<STRONG>-name</STRONG>) is the required name for the 
  field. 
  <LI>The optional second parameter (<STRONG>-default</STRONG>) is the starting 
  value for the field contents. 
  <LI>The optional third parameter (<STRONG>-size</STRONG>) is the size of the 
  field in characters. 
  <LI>The optional fourth parameter (<STRONG>-maxlength</STRONG>) is the maximum 
  number of characters the field will accomodate. </LI></UL>As with all these 
methods, the field will be initialized with its previous contents from earlier 
invocations of the script. If you want to force in the new value, overriding the 
existing one, see <A 
href="http://stein.cshl.org/WWW/software/CGI/#overriding">General note 2</A>. 
<P>When the form is processed, the value of the text field can be retrieved 
with: <PRE>      $value = $query-&gt;param('foo');
</PRE>
<P><STRONG>JavaScripting:</STRONG> You can also provide <STRONG>-onChange, 
-onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and 
<STRONG>-onSelect</STRONG> parameters to register <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
event handlers. 
<H3><A name=textarea>Creating A Big Text Field</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;textarea(-name=&gt;'foo',
	 		  -default=&gt;'starting value',
	                  -rows=&gt;10,
	                  -columns=&gt;50);

   <EM>Old style</EM>
   print $query-&gt;textarea('foo','starting value',10,50);
</PRE><STRONG>textarea()</STRONG> is just like textfield(), but it allows you to 
specify rows and columns for a multiline text entry box. You can provide a 
starting value for the field, which can be long and contain multiple lines. 
<P><STRONG>JavaScripting:</STRONG> Like textfield(), you can provide 
<STRONG>-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and 
<STRONG>-onSelect</STRONG> parameters to register <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
event handlers. 
<H3><A name=password>Creating A Password Field</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;password_field(-name=&gt;'secret',
				-value=&gt;'starting value',
				-size=&gt;50,
				-maxlength=&gt;80);

   <EM>Old style</EM>
   print $query-&gt;password_field('secret','starting value',50,80);
</PRE><STRONG>password_field()</STRONG> is identical to textfield(), except that 
its contents will be starred out on the web page. 
<H3><A name=upload>Creating a File Upload Field</A></H3><PRE>    <EM>Named parameters style</EM>
    print $query-&gt;filefield(-name=&gt;'uploaded_file',
	                    -default=&gt;'starting value',
	                    -size=&gt;50,
	 		    -maxlength=&gt;80);

    <EM>Old style</EM>
    print $query-&gt;filefield('uploaded_file','starting value',50,80);
</PRE><STRONG>filefield()</STRONG> will return a form field that prompts the 
user to upload a file. 
<UL>
  <LI>The first parameter (<STRONG>-name</STRONG>) is the required name for the 
  field. 
  <LI>The optional second parameter (<STRONG>-default</STRONG>) is the starting 
  value for the file name. This field is currently ignored by all browsers, but 
  there's always hope! 
  <LI>The optional third parameter (<STRONG>-size</STRONG>) is the size of the 
  field in characters. 
  <LI>The optional fourth parameter (<STRONG>-maxlength</STRONG>) is the maximum 
  number of characters the field will accomodate. </LI></UL>filefield() will 
return a file upload field for use with recent browsers. The browser will prompt 
the remote user to select a file to transmit over the Internet to the server. 
Other browsers currently ignore this field. 
<P>In order to take full advantage of the file upload facility you must use the 
new <A href="http://stein.cshl.org/WWW/software/CGI/#multipart">multipart form 
encoding scheme</A>. You can do this either by calling <A 
href="http://stein.cshl.org/WWW/software/CGI/#startform">startform()</A> and 
specify an encoding type of <CODE>$CGI::MULTIPART</CODE> or by using the new <A 
href="http://stein.cshl.org/WWW/software/CGI/#multipart">start_multipart_form()</A> 
method. If you don't use multipart encoding, then you'll be able to retreive the 
name of the file selected by the remote user, but you won't be able to access 
its contents. 
<P>When the form is processed, you can retrieve the entered filename by calling 
param(). <PRE>       $filename = $query-&gt;param('uploaded_file');
</PRE>where "uploaded_file" is whatever you named the file upload field. 
Depending on the browser version, the filename that gets returned may be the 
full local file path on the <STRONG>remote user's</STRONG> machine, or just the 
bare filename. If a path is provided, the follows the path conventions of the 
local machine. 
<P>The filename returned is also a file handle. You can read the contents of the 
file using standard Perl file reading calls: <PRE>	# Read a text file and print it out
	while (&lt;$filename&gt;) {
	   print;
        }

        # Copy a binary file to somewhere safe
        open (OUTFILE,"&gt;&gt;/usr/local/web/users/feedback");
	while ($bytesread=read($filename,$buffer,1024)) {
	   print OUTFILE $buffer;
        }
       close $filename;
</PRE>
<P>There are problems with the dual nature of the upload fields. If you 
<CODE>use strict</CODE>, then Perl will complain when you try to use a string as 
a filehandle. You can get around this by placing the file reading code in a 
block containing the <CODE>no strict</CODE> pragma. More seriously, it is 
possible for the remote user to type garbage into the upload field, in which 
case what you get from <B>param()</B> is not a filehandle at all, but a string. 
<P>To be safe, use the <B>upload()</B> function (new in version 2.47). When 
called with the name of an upload field, <B>upload()</B> returns a filehandle, 
or undef if the parameter is not a valid filehandle. <PRE>     $fh = $query-&gt;upload('uploaded_file');
     while (&lt;$fh&gt;) {
	   print;
     }
</PRE>
<P>In an array context, upload() will return an array of filehandles. This makes 
it possible to create forms that use the same name for multiple upload fields. 
<P>This is the recommended idiom. 
<P>You can have several file upload fields in the same form, and even give them 
the same name if you like (in the latter case <CODE>param()</CODE> will return a 
list of file names). However, if the user attempts to upload several files with 
exactly the same name, CGI.pm will only return the last of them. This is a known 
bug. 
<P>When processing an uploaded file, CGI.pm creates a temporary file on your 
hard disk and passes you a file handle to that file. After you are finished with 
the file handle, CGI.pm unlinks (deletes) the temporary file. If you need to you 
can access the temporary file directly. Its name is stored inside the CGI 
object's "private" data, and you can access it by passing the file name to the 
<A href="http://stein.cshl.org/WWW/software/CGI/#tmpfilename">tmpFileName()</A> 
method: <PRE>       $filename = $query-&gt;param('uploaded_file');
       $tmpfilename = $query-&gt;tmpFileName($filename);
</PRE>
<P>The temporary file will be deleted automatically when your program exits 
unless you manually rename it. On some operating systems (such as Windows NT), 
you will need to close the temporary file's filehandle before your program 
exits. Otherwise the attempt to delete the temporary file will fail. 
<P>A potential problem with the temporary file upload feature is that the 
temporary file is accessible to any local user on the system. In previous 
versions of this module, the temporary file was world readable, meaning that 
anyone could peak at what was being uploaded. As of version 2.36, the modes on 
the temp file have been changed to read/write by owner only. Only the Web server 
and its CGI scripts can access the temp file. Unfortunately this means that one 
CGI script can spy on another! To make the temporary files 
<STRONG>really</STRONG> private, set the CGI global variable 
$CGI::PRIVATE_TEMPFILES to 1. Alternatively, call the built-in function 
CGI::private_tempfiles(1), or just <CITE>use CGI qw/-private_tempfiles</CITE>. 
The temp file will now be unlinked as soon as it is created, making it 
inaccessible to other users. The <STRONG>downside</STRONG> of this is that you 
will be unable to access this temporary file directly 
(<CITE>tmpFileName()</CITE> will continue to return a string, but you will find 
no file at that location.) Further, since PRIVATE_TEMPFILES is a global 
variable, its setting will affect all instances of CGI.pm if you are running 
mod_perl. You can work around this limitation by declaring 
$CGI::PRIVATE_TEMPFILES as a local at the top of your script. 
<P>On Windows NT, it is impossible to make a temporary file private. This is 
because Windows doesn't allow you to delete a file before closing it. 
<P>Usually the browser sends along some header information along with the text 
of the file itself. Currently the headers contain only the original file name 
and the MIME content type (if known). Future browsers might send other 
information as well (such as modification date and size). To retrieve this 
information, call <STRONG>uploadInfo()</STRONG>. It returns a reference to an 
associative array containing all the document headers. For example, this code 
fragment retrieves the MIME type of the uploaded file (be careful to use the 
proper capitalization for "Content-Type"!): <PRE>       $filename = $query-&gt;param('uploaded_file');
       $type = $query-&gt;uploadInfo($filename)-&gt;{'Content-Type'};
       unless ($type eq 'text/html') {
	  die "HTML FILES ONLY!";
       }
</PRE>
<P><STRONG>JavaScripting:</STRONG> Like textfield(), filefield() accepts 
<STRONG>-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and 
<STRONG>-onSelect</STRONG> parameters to register <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
event handlers. <A 
href="http://stein.cshl.org/WWW/software/CGI/#upload_caveats">Caveats and 
potential problems in the file upload feature.</A> 
<H3><A name=menu>Creating A Popup Menu</A></H3><PRE>  <EM>Named parameter style</EM>
  print $query-&gt;popup_menu(-name=&gt;'menu_name',
                            -values=&gt;[qw/eenie meenie minie/], 
			    -labels=&gt;{'eenie'=&gt;'one',
                                         'meenie'=&gt;'two',
                                         'minie'=&gt;'three'},
	                    -default=&gt;'meenie');

  print $query-&gt;popup_menu(-name=&gt;'menu_name',
			    -values=&gt;['eenie','meenie','minie'],
	                    -default=&gt;'meenie');
  
  <EM>Old style</EM>
  print $query-&gt;popup_menu('menu_name',
                              ['eenie','meenie','minie'],'meenie',
                              {'eenie'=&gt;'one','meenie'=&gt;'two','minie'=&gt;'three'});
</PRE><STRONG>popup_menu()</STRONG> creates a menu. 
<UL>
  <LI>The required first argument (<STRONG>-name</STRONG>) is the menu's name. 
  <LI>The required second argument (<STRONG>-values</STRONG>) is an array 
  <EM>reference</EM> containing the list of menu items in the menu. You can pass 
  the method an anonymous array, as shown in the example, or a reference to a 
  named array, such as <TT>\@foo</TT>. If you pass a <EM>HASH reference</EM>, 
  the keys will be used for the menu values, and the values will be used for the 
  menu labels (see -labels below). 
  <LI>The optional third parameter (<STRONG>-default</STRONG>) is the name of 
  the default menu choice. If not specified, the first item will be the default. 
  The value of the previous choice will be maintained across queries. 
  <LI>The optional fourth parameter (<STRONG>-labels</STRONG>) allows you to 
  pass a reference to an associative array containing user-visible labels for 
  one or more of the menu items. You can use this when you want the user to see 
  one menu string, but have the browser return your program a different one. If 
  you don't specify this, the value string will be used instead ("eenie", 
  "meenie" and "minie" in this example). This is equivalent to using a hash 
  reference for the -values parameter. </LI></UL>When the form is processed, the 
selected value of the popup menu can be retrieved using: <PRE>     $popup_menu_value = $query-&gt;param('menu_name');
</PRE><STRONG>JavaScripting:</STRONG> You can provide <STRONG>-onChange, 
-onFocus, -onMouseOver, -onMouseOut, and -onBlur</STRONG> parameters to register 
<A href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
event handlers. 
<H3><A name=scrolling_list>Creating A Scrolling List</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;scrolling_list(-name=&gt;'list_name',
                                -values=&gt;['eenie','meenie','minie','moe'],
                                -default=&gt;['eenie','moe'],
	                        -size=&gt;5,
	                        -multiple=&gt;'true',
                                -labels=&gt;\%labels);

   <EM>Old style</EM>
   print $query-&gt;scrolling_list('list_name',
                                ['eenie','meenie','minie','moe'],
                                ['eenie','moe'],5,'true',
                                \%labels);

</PRE><STRONG>scrolling_list()</STRONG> creates a scrolling list. 
<UL>
  <LI>The first and second arguments (<STRONG>-name, -values</STRONG>)are the 
  list name and values, respectively. As in the popup menu, the second argument 
  should be an array reference or hash reference. In the latter case, the values 
  of the hash are used as the human-readable labels in the list. 
  <LI>The optional third argument (<STRONG>-default</STRONG>)can be either a 
  reference to a list containing the values to be selected by default, or can be 
  a single value to select. If this argument is missing or undefined, then 
  nothing is selected when the list first appears. 
  <LI>The optional fourth argument (<STRONG>-size</STRONG>) is the display size 
  of the list. 
  <LI>The optional fifth argument (<STRONG>-multiple</STRONG>) can be set to 
  true to allow multiple simultaneous selections. 
  <LI>The option sixth argument (<STRONG>-labels</STRONG>) can be used to assign 
  user-visible labels to the list items different from the ones used for the 
  values as above. This is equivalent to passing a hash reference to -values. In 
  this example we assume that an associative array <CODE>%labels</CODE> has 
  already been created. </LI></UL>When this form is processed, all selected list 
items will be returned as a list under the parameter name 'list_name'. The 
values of the selected items can be retrieved with: <PRE>     @selected = $query-&gt;param('list_name');
</PRE><STRONG>JavaScripting:</STRONG> You can provide <STRONG>-onChange, 
-onFocus, -onMouseOver, -onMouseOut</STRONG> and <STRONG>-onBlur</STRONG> 
parameters to register <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> 
event handlers. 
<H3><A name=checkbox_group>Creating A Group Of Related Checkboxes</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;checkbox_group(-name=&gt;'group_name',
                                -values=&gt;['eenie','meenie','minie','moe'],
                                -default=&gt;['eenie','moe'],
	                        -linebreak=&gt;'true',
	                        -labels=&gt;\%labels);

   <EM>Old Style</EM>
   print $query-&gt;checkbox_group('group_name',
                                ['eenie','meenie','minie','moe'],
                                ['eenie','moe'],'true',\%labels);

   <EM>HTML3 Browsers Only</EM>
   print $query-&gt;checkbox_group(-name=&gt;'group_name',
                                -values=&gt;['eenie','meenie','minie','moe'],
                                -rows=&gt;2,-columns=&gt;2);
</PRE><STRONG>checkbox_group()</STRONG> creates a list of checkboxes that are 
related by the same name. 
<UL>
  <LI>The first and second arguments (<STRONG>-name, -values</STRONG>) are the 
  checkbox name and values, respectively. As in the popup menu, the second 
  argument should be an array reference or a hash reference. These values are 
  used for the user-readable labels printed next to the checkboxes as well as 
  for the values passed to your script in the query string. 
  <LI>The optional third argument (<STRONG>-default</STRONG>) can be either a 
  reference to a list containing the values to be checked by default, or can be 
  a single value to checked. If this argument is missing or undefined, then 
  nothing is selected when the list first appears. 
  <LI>The optional fourth argument (<STRONG>-linebreak</STRONG>) can be set to 
  true to place line breaks between the checkboxes so that they appear as a 
  vertical list. Otherwise, they will be strung together on a horizontal line. 
  When the form is procesed, all checked boxes will be returned as a list under 
  the parameter name 'group_name'. The values of the "on" checkboxes can be 
  retrieved with: 
  <LI>The optional fifth argument (<STRONG>-labels</STRONG>) is a reference to 
  an hash of checkbox labels. This allows you to use different strings for the 
  user-visible button labels and the values sent to your script. In this example 
  we assume that an associative array <CODE>%labels</CODE> has previously been 
  created. This is equivalent to passing a hash reference to -values. If you 
  don't use <STRONG>-nolabels</STRONG>, CGI.pm will add HTML label tag around 
  each checkbox and its label, so a browser can identify the text as form 
  element label properly. 
  <LI>The optional parameter <STRONG>-nolabels</STRONG> can be used to suppress 
  the printing of labels next to the button. This is useful if you want to 
  capture the button elements individually and use them inside labeled HTML3 
  tables. 
  <LI><STRONG>Browsers that understand HTML3 tables</STRONG> (such as Netscape) 
  can take advantage of the optional parameters <STRONG>-rows</STRONG>, and 
  <STRONG>-columns</STRONG>. These parameters cause checkbox_group() to return 
  an HTML3 compatible table containing the checkbox group formatted with the 
  specified number of rows and columns. You can provide just the -columns 
  parameter if you wish; checkbox_group will calculate the correct number of 
  rows for you. 
  <P>To include row and column headings in the returned table, you can use the 
  <STRONG>-rowheaders</STRONG> and <STRONG>-colheaders</STRONG> parameters. Both 
  of these accept a pointer to an array of headings to use. The headings are 
  just decorative. They don't reorganize the interpetation of the checkboxes -- 
  they're still a single named unit. 
  <P>When viewed with browsers that don't understand HTML3 tables, the -rows and 
  -columns parameters will leave you with a group of buttons that may be 
  awkwardly formatted but still useable. However, if you add row and/or column 
  headings, the resulting text will be very hard to read. </P></LI></UL>When the 
form is processed, the list of checked buttons in the group can be retrieved 
like this: <PRE>     @turned_on = $query-&gt;param('group_name');
</PRE>This function actually returns an array of button elements. You can 
capture the array and do interesting things with it, such as incorporating it 
into your own tables or lists. The <STRONG>-nolabels</STRONG> option is also 
useful in this regard: <PRE>       @h = $query-&gt;checkbox_group(-name=&gt;'choice',
                                    -value=&gt;['fee','fie','foe'],
                                    -nolabels=&gt;1);
       create_nice_table(@h);
</PRE><STRONG>JavaScripting:</STRONG> You can provide an 
<STRONG>-onClick</STRONG> parameter to register some <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> code 
to be performed every time the user clicks on any of the buttons in the group. 
<H3><A name=checkbox>Creating A Standalone Checkbox</A></H3><PRE>   <EM>Named parameter list</EM>
   print $query-&gt;checkbox(-name=&gt;'checkbox_name',
			   -checked=&gt;'checked',
		           -value=&gt;'TURNED ON',
		           -label=&gt;'Turn me on');

   <EM>Old style</EM>
   print $query-&gt;checkbox('checkbox_name',1,'TURNED ON','Turn me on');
</PRE><STRONG>checkbox()</STRONG> is used to create an isolated checkbox that 
isn't logically related to any others. 
<UL>
  <LI>The first parameter (<STRONG>-name</STRONG> is the required name for the 
  checkbox. It will also be used for the user-readable label printed next to the 
  checkbox. 
  <LI>The optional second parameter (<STRONG>-checked</STRONG> specifies that 
  the checkbox is turned on by default. Aliases for this parameter are 
  <STRONG>-selected</STRONG> and <STRONG>-on</STRONG>. 
  <LI>The optional third parameter (<STRONG>-value</STRONG> specifies the value 
  of the checkbox when it is checked. If not provided, the word "on" is assumed. 

  <LI>The optional fourth parameter (<STRONG>-label</STRONG> assigns a 
  user-visible label to the button. If not provided, the checkbox's name will be 
  used. CGI.pm will add HTML label tag around the checkbox and its label, so a 
  browser can identify the text as form element label properly. </LI></UL>The 
value of the checkbox can be retrieved using: <PRE>     $turned_on = $query-&gt;param('checkbox_name');
</PRE><STRONG>JavaScripting:</STRONG> You can provide an <CODE>-onClick</CODE> 
parameter to register some <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> code 
to be performed every time the user clicks on the button. 
<H3><A name=radio>Creating A Radio Button Group</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;radio_group(-name=&gt;'group_name',
			     -values=&gt;['eenie','meenie','minie'],
                             -default=&gt;'meenie',
			     -linebreak=&gt;'true',
			     -labels=&gt;\%labels);

   <EM>Old style</EM>
   print $query-&gt;radio_group('group_name',['eenie','meenie','minie'],
                                          'meenie','true',\%labels);

   <EM>HTML3-compatible browsers only</EM>
   print $query-&gt;radio_group(-name=&gt;'group_name',
                                -values=&gt;['eenie','meenie','minie','moe'],
	                        -rows=&gt;2,-columns=&gt;2);
</PRE><STRONG>radio_group()</STRONG> creates a set of logically-related radio 
buttons. Turning one member of the group on turns the others off. 
<UL>
  <LI>The first argument (<STRONG>-name</STRONG> is the name of the group and is 
  required. 
  <LI>The second argument (<STRONG>-values</STRONG> is the list of values for 
  the radio buttons. The values and the labels that appear on the page are 
  identical. Pass an array <EM>reference</EM> in the second argument, either 
  using an anonymous array, as shown, or by referencing a named array as in 
  <CODE>\@foo</CODE>. You may also use a hash reference in order to produce 
  human-readable labels that are different from the values that will be returned 
  as parameters to the CGI script. 
  <LI>The optional third parameter (<STRONG>-default</STRONG> is the value of 
  the default button to turn on. If not specified, the first item will be the 
  default. Specify some nonexistent value, such as "-" if you don't want any 
  button to be turned on. 
  <LI>The optional fourth parameter (<STRONG>-linebreak</STRONG> can be set to 
  'true' to put line breaks between the buttons, creating a vertical list. 
  <LI>The optional fifth parameter (<STRONG>-labels</STRONG> specifies an 
  associative array containing labels to be printed next to each button. If not 
  provided the button value will be used instead. This example assumes that the 
  associative array <CODE>%labels</CODE> has already been defined. This is 
  equivalent to passing a hash reference to -values. If you don't use 
  <STRONG>-nolabels</STRONG>, CGI.pm will add HTML label tag around each radio 
  button and its label, so a browser can identify the text as form element label 
  properly. 
  <LI>The optional parameter <STRONG>-nolabels</STRONG> can be used to suppress 
  the printing of labels next to the button. This is useful if you want to 
  capture the button elements individually and use them inside labeled HTML3 
  tables. 
  <LI><STRONG>Browsers that understand HTML3 tables</STRONG> (such as Netscape) 
  can take advantage of the optional parameters <STRONG>-rows</STRONG>, and 
  <STRONG>-columns</STRONG>. These parameters cause radio_group() to return an 
  HTML3 compatible table containing the radio cluster formatted with the 
  specified number of rows and columns. You can provide just the -columns 
  parameter if you wish; radio_group will calculate the correct number of rows 
  for you. 
  <P>To include row and column headings in the returned table, you can use the 
  <STRONG>-rowheader</STRONG> and <STRONG>-colheader</STRONG> parameters. Both 
  of these accept a pointer to an array of headings to use. The headings are 
  just decorative. They don't reorganize the interpetation of the radio buttons 
  -- they're still a single named unit. 
  <P>When viewed with browsers that don't understand HTML3 tables, the -rows and 
  -columns parameters will leave you with a group of buttons that may be 
  awkwardly formatted but still useable. However, if you add row and/or column 
  headings, the resulting text will be very hard to read. </P></LI></UL>When the 
form is processed, the selected radio button can be retrieved using: <PRE>       $which_radio_button = $query-&gt;param('group_name');
</PRE>This function actually returns an array of button elements. You can 
capture the array and do interesting things with it, such as incorporating it 
into your own tables or lists The <STRONG>-nolabels</STRONG> option is useful in 
this regard.: <PRE>       @h = $query-&gt;radio_group(-name=&gt;'choice',
                                 -value=&gt;['fee','fie','foe'],
                                 -nolabels=&gt;1);
       create_nice_table(@h);
</PRE>
<P><STRONG>JavaScripting</STRONG>: You can provide an <STRONG>-onClick</STRONG> 
parameter to register some <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> code 
to be performed every time the user clicks on any of the buttons in the group. 
<H3><A name=submit>Creating A Submit Button</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;submit(-name=&gt;'button_name',
		        -value=&gt;'value');

  <EM>Old style</EM>
  print $query-&gt;submit('button_name','value');
</PRE><STRONG>submit()</STRONG> will create the query submission button. Every 
form should have one of these. 
<UL>
  <LI>The first argument (<STRONG>-name</STRONG>is optional. You can give the 
  button a name if you have several submission buttons in your form and you want 
  to distinguish between them. 
  <LI>The second argument (<STRONG>-value</STRONG>is also optional. This gives 
  the button a value that will be passed to your script in the query string, and 
  will also appear as the user-visible label. 
  <P>You can figure out which of several buttons was pressed by using different 
  values for each one: <PRE>    $which_one = $query-&gt;param('button_name');
</PRE>
  <LI>You can use <STRONG>-label</STRONG> as an alias for 
  <STRONG>-value</STRONG>. I always get confused about which of 
  <CODE>-name</CODE> and <CODE>-value</CODE> changes the user-visible label on 
  the button. </LI></UL><STRONG>JavaScripting:</STRONG> You can provide an 
<STRONG>-onClick</STRONG> parameter to register some <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> code 
to be performed every time the user clicks on the button. You can't prevent a 
form from being submitted, however. You must provide an 
<STRONG>-onSubmit</STRONG> handler to the <A 
href="http://stein.cshl.org/WWW/software/CGI/#">form itself</A> to do that. 
<H3><A name=reset>Creating A Reset Button</A></H3><PRE>  print $query-&gt;reset
</PRE><STRONG>reset()</STRONG> creates the "reset" button. It undoes whatever 
changes the user has recently made to the form, but does <STRONG>not</STRONG> 
necessarily reset the form all the way to the defaults. See 
<STRONG>defaults()</STRONG> for that. It takes the optional label for the button 
("Reset" by default). <STRONG>JavaScripting:</STRONG> You can provide an 
<STRONG>-onClick</STRONG> parameter to register some <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScript</A> code 
to be performed every time the user clicks on the button. 
<H3><A name=defaults>Creating A Defaults Button</A></H3><PRE>  print $query-&gt;defaults('button_label')
</PRE><STRONG>defaults()</STRONG> creates "reset to defaults" button. It takes 
the optional label for the button ("Defaults" by default). When the user presses 
this button, the form will automagically be cleared entirely and set to the 
defaults you specify in your script, just as it was the first time it was 
called. 
<H3><A name=hidden>Creating A Hidden Field</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;hidden(-name=&gt;'hidden_name',
                        -default=&gt;['value1','value2'...]);

   <EM>Old style</EM>
   print $query-&gt;hidden('hidden_name','value1','value2'...);
</PRE><STRONG>hidden()</STRONG> produces a text field that can't be seen by the 
user. It is useful for passing state variable information from one invocation of 
the script to the next. 
<UL>
  <LI>The first argument (<STRONG>-name</STRONG>) is required and specifies the 
  name of this field. 
  <LI>The second and subsequent arguments specify the value for the hidden 
  field. This is a quick and dirty way of passing perl arrays through forms. If 
  you use the named parameter style, you must provide the parameter 
  <STRONG>-default</STRONG> and an array reference here. </LI></UL><STRONG><A 
name=hidden_fields_warning><IMG alt=[CAUTION] 
src="CGI_pm-aPerl5CGI_Library_files/caution.xbm"> As of version 2.0 I have 
changed the behavior of hidden fields once again. Read this if you use hidden 
fields.</A></STRONG> 
<P>Hidden fields used to behave differently from all other fields: the provided 
default values always overrode the "sticky" values. This was the behavior people 
seemed to expect, however it turns out to make it harder to write 
state-maintaining forms such as shopping cart programs. Therefore I have made 
the behavior consistent with other fields. 
<P>Just like all the other form elements, the value of a hidden field is 
"sticky". If you want to replace a hidden field with some other values after the 
script has been called once you'll have to do it manually before writing out the 
form element: <PRE>     $query-&gt;param('hidden_name','new','values','here');
     print $query-&gt;hidden('hidden_name');
</PRE>Fetch the value of a hidden field this way: <PRE>    $hidden_value = $query-&gt;param('hidden_name');
            -or (for values created with arrays)-
    @hidden_values = $query-&gt;param('hidden_name');
</PRE>
<H3><A name=image>Creating a Clickable Image Button</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;image_button(-name=&gt;'button_name',
                              -src=&gt;'/images/NYNY.gif',
                              -align=&gt;'MIDDLE');	

   <EM>Old style</EM>
   print $query-&gt;image_button('button_name','/source/URL','MIDDLE');

</PRE><STRONG>image_button()</STRONG> produces an inline image that acts as a 
submission button. When selected, the form is submitted and the clicked (x,y) 
coordinates are submitted as well. 
<UL>
  <LI>The first argument(<STRONG>-name</STRONG> is required and specifies the 
  name of this field. 
  <LI>The second argument (<STRONG>-src</STRONG>specifies the URL of the image 
  to display. It must be one of the types supported by inline images (e.g. GIF), 
  but can be any local or remote URL. 
  <LI>The third argument (<STRONG>-align</STRONG>is anything you might want to 
  use in the ALIGN attribute, such as TOP, BOTTOM, LEFT, RIGHT or MIDDLE. This 
  field is optional. </LI></UL>When the image is clicked, the results are passed 
to your script in two parameters named "button_name.x" and "button_name.y", 
where "button_name" is the name of the image button. <PRE>    $x = $query-&gt;param('button_name.x');
    $y = $query-&gt;param('button_name.y');
</PRE><STRONG>JavaScripting:</STRONG> Current versions of JavaScript do not 
honor the <CODE>-onClick</CODE> handler, unlike other buttons. 
<H3><A name=button>Creating a JavaScript Button</A></H3><PRE>   <EM>Named parameter style</EM>
   print $query-&gt;button(-name=&gt;'button1',
                           -value=&gt;'Click Me',
                           -onClick=&gt;'doButton(this)');	

   <EM>Old style</EM>
   print $query-&gt;image_button('button1','Click Me','doButton(this)');

</PRE><STRONG>button()</STRONG> creates a JavaScript button. When the button is 
pressed, the JavaScript code pointed to by the <CODE>-onClick</CODE> parameter 
is executed. This only works with Netscape 2.0 and higher. Other browsers do not 
recognize JavaScript and probably won't even display the button. 
<UL>
  <LI>The first argument(<STRONG>-name</STRONG> is required and specifies the 
  name of this field. 
  <LI>The second argument (<STRONG>-value</STRONG> gives the button a value, and 
  will be used as the user-visible label on the button. 
  <LI>The third argument (<STRONG>-onClick</STRONG> is any valid JavaScript 
  code. It's usually a call to a JavaScript function defined somewhere else (see 
  the <A href="http://stein.cshl.org/WWW/software/CGI/#html">start_html()</A> 
  method), but can be any JavaScript you like. Multiple lines are allowed, but 
  you must be careful not to include any double quotes in the JavaScript text. 
  </LI></UL>See <A 
href="http://stein.cshl.org/WWW/software/CGI/#javascripting">JavaScripting</A> 
for more information. 
<H3><A name=escape>Controlling HTML Autoescaping</A></H3>By default, if you use 
a special HTML character such as &gt;, &lt; or &amp; as the label or value of a 
button, it will be escaped using the appropriate HTML escape sequence (e.g. 
&amp;gt;). This lets you use anything at all for the text of a form field 
without worrying about breaking the HTML document. However, it may also 
interfere with your ability to use special characters, such as  as default 
contents of fields. You can turn this feature on and off with the method 
<CODE>autoEscape()</CODE>. 
<P>Use <PRE>    $query-&gt;autoEscape(undef);
</PRE>to turn automatic HTML escaping off, and <PRE>    $query-&gt;autoEscape('true');
</PRE>to turn it back on. 
<HR>

<H2><A name=import>Importing CGI Methods</A></H2>A large number of scripts 
allocate only a single query object, use it to read parameters or to create a 
fill-out form, and then discard it. For this type of script, it may be handy to 
import CGI module methods into your name space. The most common syntax for this 
is: 
<BLOCKQUOTE><PRE>use CGI qw(:standard);
</PRE></BLOCKQUOTE>This imports the standard methods into your namespace. Now 
instead of getting parameters like this: 
<BLOCKQUOTE><PRE>use CGI;
$dinner = $query-&gt;param('entree');
</PRE></BLOCKQUOTE>You can do it like this: 
<BLOCKQUOTE><PRE>use CGI qw(:standard);
$dinner = param('entree');
</PRE></BLOCKQUOTE>Similarly, instead of creating a form like this: 
<BLOCKQUOTE><PRE>print $query-&gt;start_form,
      "Check here if you're happy: ",
      $query-&gt;checkbox(-name=&gt;'happy',-value=&gt;'Y',-checked=&gt;1),
      "&lt;P&gt;",
      $query-&gt;submit,
      $query-&gt;end_form;
</PRE></BLOCKQUOTE>You can create it like this: 
<BLOCKQUOTE><PRE>print start_form,
      "Check here if you're happy: ",
      checkbox(-name=&gt;'happy',-value=&gt;'Y',-checked=&gt;1),
      p,
      submit,
      end_form;
</PRE></BLOCKQUOTE>Even though there's no CGI object in view in the second 
example, state is maintained using an implicit CGI object that's created 
automatically. The form elements created this way are sticky, just as before. If 
you need to get at the implicit CGI object directly, you can refer to it as: 
<BLOCKQUOTE><PRE>$CGI::Q;
</PRE></BLOCKQUOTE>
<P>The <STRONG>use CGI</STRONG> statement is used to import method names into 
the current name space. There is a slight overhead for each name you import, but 
ordinarily is nothing to worry about. You can import selected method names like 
this: 
<BLOCKQUOTE><PRE>   use CGI qw(header start_html end_html);
</PRE></BLOCKQUOTE>Ordinarily, however, you'll want to import groups of methods 
using export tags. Export tags refer to sets of logically related methods which 
are imported as a group with <STRONG>use</STRONG>. Tags are distinguished from 
ordinary methods by beginning with a ":" character. This example imports the 
methods dealing with the CGI protocol (<CODE>param()</CODE> and the like) as 
well as shortcuts that generate HTML2-compliant tags: 
<BLOCKQUOTE><PRE>use CGI qw(:cgi :html2);
</PRE></BLOCKQUOTE>Currently there are 8 method families defined in CGI.pm. They 
are: 
<DL>
  <DT><CITE>:cgi</CITE> 
  <DD>These are all the tags that support one feature or another of the CGI 
  protocol, including param(), path_info(), cookie(), request_method(), header() 
  and the like. 
  <DT><CITE>:form</CITE> 
  <DD>These are all the form element-generating methods, including start_form(), 
  textfield(), etc. 
  <DT><CITE>:html2</CITE> 
  <DD>These are HTML2-defined shortcuts such as br(), p() and head(). It also 
  includes such things as start_html() and end_html() that aren't exactly HTML2, 
  but are close enough. 
  <DT><CITE>:html3</CITE> 
  <DD>These contain various HTML3 tags for tables, frames, super- and 
  subscripts, applets and other objects. 
  <DT><CITE>:html4</CITE> 
  <DD>These contain various HTML4 tags, including table headers and footers. 
  <DT><CITE>:netscape</CITE> 
  <DD>These are Netscape extensions not included in the HTML3 category including 
  blink() and center(). 
  <DT><CITE>:html</CITE> 
  <DD>These are all the HTML generating shortcuts, comprising the union of 
  <CITE>html2, html3,</CITE> and <CITE>netscape</CITE>. 
  <DT><CITE>:multipart</CITE> 
  <DD>These are various functions that simplify creating documents of the 
  various multipart MIME types, and are useful for implementing server push. 
  <DT><CITE>:standard</CITE> 
  <DD>This is the union of <CITE>html2, html3, html4, form,</CITE> and 
  <CITE>:cgi</CITE>. 
  <DT><CITE>:all</CITE> 
  <DD>This imports all the public methods into your namespace! </DD></DL>
<H3>Pragmas</H3>In addition to importing individual methods and method families, 
<CITE>use CGI</CITE> recognizes several pragmas, all proceeded by dashes. 
<DL>
  <DT><B>-any</B> 
  <DD>When you <CITE>use CGI -any</CITE>, then any method that the query object 
  doesn't recognize will be interpreted as a new HTML tag. This allows you to 
  support the next <CITE>ad hoc</CITE> Netscape or Microsoft HTML extension. For 
  example, to support Netscape's latest tag, &lt;GRADIENT&gt; (which causes the 
  user's desktop to be flooded with a rotating gradient fill until his machine 
  reboots), you can use something like this: 
  <BLOCKQUOTE><PRE>      use CGI qw(-any);
      $q=new CGI;
      print $q-&gt;gradient({speed=&gt;'fast',start=&gt;'red',end=&gt;'blue'});
      </PRE></BLOCKQUOTE>Since using <CITE>any</CITE> causes any mistyped 
  method name to be interpreted as an HTML tag, use it with care or not at all. 
  <P></P>
  <DT><B>-compile</B> 
  <DD>This causes the indicated autoloaded methods to be compiled up front, 
  rather than deferred to later. This is useful for scripts that run for an 
  extended period of time under FastCGI or mod_perl, and for those destined to 
  be crunched by Malcom Beattie's Perl compiler. Use it in conjunction with the 
  methods or method familes you plan to use. 
  <BLOCKQUOTE><PRE>      use CGI qw(-compile :standard :html3);
      </PRE></BLOCKQUOTE>or even 
  <BLOCKQUOTE><PRE>      use CGI qw(-compile :all);
      </PRE></BLOCKQUOTE>
  <P>Note that using the -compile pragma in this way will always have the effect 
  of importing the compiled functions into the current namespace. If you want to 
  compile without importing use the <A 
  href="http://stein.cshl.org/WWW/software/CGI/#compile">compile()</A> method 
  instead. 
  <P></P>
  <DT><B>-autoload</B> 
  <DD>Overrides the autoloader so that any function in your program that is not 
  recognized is referred to CGI.pm for possible evaluation. This allows you to 
  use all the CGI.pm functions without adding them to your symbol table, which 
  is of concern for mod_perl users who are worried about memory consumption. 
  <STRONG>Warning:</STRONG> when <EM>-autoload</EM> is in effect, you cannot use 
  "poetry mode" (functions without the parenthesis). Use <CITE>hr()</CITE> 
  rather than <CITE>hr</CITE>, or add something like <EM>use subs qw/hr p 
  header/</EM> to the top of your script. 
  <P></P>
  <DT><B>-nosticky</B> 
  <DD>Turns off "sticky" behavior in fill-out forms. Every form element will act 
  as if you passed -override. 
  <P></P>
  <DT><B>-no_xhtml</B> 
  <DD>By default, CGI.pm versions 2.69 and higher emit XHTML (<A 
  href="http://www.w3.org/TR/xhtml1/">http://www.w3.org/TR/xhtml1/</A>). The 
  -no_xhtml pragma disables this feature. Thanks to Michalis Kabrianis 
  &lt;kabrianis@hellug.gr&gt; for this feature. 
  <P></P>
  <DT><B>-nph</B> 
  <DD>This makes CGI.pm produce a header appropriate for an NPH (no parsed 
  header) script. You may need to do other things as well to tell the server 
  that the script is NPH. See the <A 
  href="http://stein.cshl.org/WWW/software/CGI/#nph">discussion of NPH 
  scripts</A> below. 
  <P></P>
  <DT><B>-oldstyle_urls</B> 
  <DD>Separate the name=value pairs in CGI parameter query strings emitted by 
  self_url() and query_string() with ampersands. Otherwise, CGI.pm emits 
  HTML-compliant semicolons. If you use this form, be sure to escape ampersands 
  into HTML entities with escapeHTML. Example: 
  <BLOCKQUOTE><PRE>      $href = $q-&gt;self_url();
      $href = escapeHTML($href);
      print <A href="http://stein.cshl.org/WWW/software/CGI/$href">I'm talking to myself</A>
      </PRE></BLOCKQUOTE>
  <P></P>
  <DT><B>-newstyle_urls</B> 
  <DD>Separate the name=value pairs in CGI parameter query strings with 
  semicolons rather than ampersands. For example: 
  <BLOCKQUOTE><PRE>      name=fred;age=24;favorite_color=3
      </PRE></BLOCKQUOTE>As of version 2.64, this is the default style. 
  <DT><B>-no_debug</B> 
  <DD>This turns off the command-line processing features. If you want to run a 
  CGI.pm script from the command line to produce HTML, and you don't want it 
  interpreting arguments on the command line as CGI name=value arguments, then 
  use this pragma: 
  <BLOCKQUOTE><PRE>      use CGI qw(-no_debug :standard);
      </PRE></BLOCKQUOTE>
  <P></P>
  <DT><B>-debug</B> 
  <DD>This turns on full debugging. In addition to reading CGI arguments from 
  the command-line processing, CGI.pm will pause and try to read arguments from 
  STDIN, producing the message "(offline mode: enter name=value pairs on 
  standard input)" features. 
  <P>See <A 
  href="http://stein.cshl.org/WWW/software/CGI/#debugging">debugging</A> for 
  more details. 
  <P></P>
  <DT><B>-private_tempfiles</B> 
  <DD>CGI.pm can process uploaded file. Ordinarily it spools the uploaded file 
  to a temporary directory, then deletes the file when done. However, this opens 
  the risk of eavesdropping as described in the <A 
  href="http://stein.cshl.org/WWW/software/CGI/#upload">file upload section.</A> 
  Another CGI script author could peek at this data during the upload, even if 
  it is confidential information. On Unix systems, the <B>-private_tempfiles</B> 
  pragma will cause the temporary file to be unlinked as soon as it is opened 
  and before any data is written into it, eliminating the risk of eavesdropping. 
  </DD></DL>
<H3>Special Forms for Importing HTML-Tag Functions</H3>Many of the methods 
generate HTML tags. As described below, tag functions automatically generate 
both the opening and closing tags. For example: <PRE>  print h1('Level 1 Header');
</PRE>produces <PRE>  &lt;H1&gt;Level 1 Header&lt;/H1&gt;
</PRE>There will be some times when you want to produce the start and end tags 
yourself. In this case, you can use the form start_I<CITE>tag_name</CITE> and 
end_I<CITE>tag_name</CITE>, as in: <PRE>  print start_h1,'Level 1 Header',end_h1;
</PRE>With a few exceptions (described below), start_<CITE>tag_name</CITE> and 
end_I<CITE>tag_name</CITE> functions are not generated automatically when you 
<CITE>use CGI</CITE>. However, you can specify the tags you want to generate 
<CITE>start/end</CITE> functions for by putting an asterisk in front of their 
name, or, alternatively, requesting either "start_<CITE>tag_name</CITE>" or 
"end_<CITE>tag_name</CITE>" in the import list. 
<P>Example: <PRE>  use CGI qw/:standard *table start_ul/;
</PRE>In this example, the following functions are generated in addition to the 
standard ones: 
<OL>
  <LI><CODE>start_table()</CODE> (generates a &lt;TABLE&gt; tag) 
  <LI><CODE>end_table()</CODE> (generates a &lt;/TABLE&gt; tag) 
  <LI><CODE>start_ul()</CODE> (generates a &lt;UL&gt; tag) 
  <LI><CODE>end_ul()</CODE> (generates a &lt;/UL&gt; tag) </LI></OL>
<H3>AUTOESCAPING HTML</H3>By default, all HTML that are emitted by the 
form-generating functions are passed through a function called escapeHTML(): 
<BLOCKQUOTE><PRE>$escaped_string = escapeHTML("unescaped string");
</PRE></BLOCKQUOTE>
<P>Provided that you have specified a character set of ISO-8859-1 (the default), 
the standard HTML escaping rules will be used. The "&lt;" character becomes 
"&amp;lt;", "&gt;" becomes "&amp;gt;", "&amp;" becomes "&amp;amp;", and the 
quote character becomes "&amp;quot;". In addition, the hexadecimal 0x8b and 0x9b 
characters, which many windows-based browsers interpret as the left and right 
angle-bracket characters, are replaced by their numeric HTML entities 
("&amp;#139" and "&amp;#155;"). If you manually change the charset, either by 
calling the charset() method explicitly or by passing a -charset argument to 
header(), then <B>all</B> characters will be replaced by their numeric entities, 
since CGI.pm has no lookup table for all the possible encodings. 
<P>Autoescaping does not apply to other HTML-generating functions, such as h1(). 
You should call escapeHTML() yourself on any data that is passed in from the 
outside, such as nasty text that people may enter into guestbooks. 
<P>To change the character set, use charset(). To turn autoescaping off 
completely, use autoescape(): 
<BLOCKQUOTE><PRE>$charset = charset([$charset]);  # Get or set the current character set.

$flag = autoEscape([$flag]);     # Get or set the value of the autoescape flag.
</PRE></BLOCKQUOTE>
<H3>PRETTY-PRINTING HTML</H3>By default, all the HTML produced by these 
functions comes out as one long line without carriage returns or indentation. 
This is yuck, but it does reduce the size of the documents by 10-20%. To get 
pretty-printed output, please use <CITE>CGI::Pretty</CITE>, a subclass 
contributed by <A href="mailto:bpaulsen@lehman.com">Brian Paulsen</A>. 
<H3>Optional Utility Functions</H3>In addition to the standard imported 
functions, there are a few optional functions that you must request by name if 
you want them. They were originally intended for internal use only, but are now 
made available by popular request. 
<H4>escape(), unescape()</H4>
<BLOCKQUOTE><PRE>use CGI qw/escape unescape/;
$q = escape('This $string contains ~wonderful~ characters');
$u = unescape($q);
</PRE></BLOCKQUOTE>These functions escape and unescape strings according to the 
URL hex escape rules. For example, the space character will be converted into 
the string "%20". 
<H4>escapeHTML(), unescapeHTML()</H4>
<BLOCKQUOTE><PRE>use CGI qw/escapeHTML unescapeHTML/;
$q = escapeHTML('This string is &lt;illegal&gt; html!');
$u = unescapeHTML($q);
</PRE></BLOCKQUOTE>These functions escape and unescape strings according to the 
HTML character entity rules. For example, the character &lt; will be escaped as 
&amp;lt;. 
<H4><A name=compile>compile()</A></H4>Ordinarily CGI.pm autoloads most of its 
functions on an as-needed basis. This speeds up the loading time by deferring 
the compilation phase. However, if you are using mod_perl, FastCGI or another 
system that uses a persistent Perl interpreter, you will want to precompile the 
methods at initialization time. To accomplish this, call the package function 
<B>compile()</B> like this: 
<BLOCKQUOTE><PRE>use CGI ();
CGI-&gt;compile(':all');
</PRE></BLOCKQUOTE>The arguments to <B>compile()</B> are a list of method names 
or sets, and are identical to those accepted by the use operator. 
<HR>

<H2><A name=debugging>Debugging</A></H2>If you are running the script from the 
command line or in the perl debugger, you can pass the script a list of keywords 
or parameter=value pairs on the command line or from standard input (you don't 
have to worry about tricking your script into reading from environment 
variables). You can pass keywords like this: <PRE>   my_script.pl keyword1 keyword2 keyword3
</PRE><EM>or this:</EM> <PRE>   my_script.pl keyword1+keyword2+keyword3
</PRE><EM>or this:</EM> <PRE>   my_script.pl name1=value1 name2=value2
</PRE><EM>or this:</EM> <PRE>   my_script.pl name1=value1&amp;name2=value2
</PRE>If you pass the <B>-debug</B> pragma to CGI.pm, you can send CGI 
name-value pairs as newline-delimited parameters on standard input: <PRE>   % my_script.pl
   first_name=fred
   last_name=flintstone
   occupation='granite miner'
   ^D
</PRE>
<P>When debugging, you can use quotation marks and the backslash character to 
escape spaces and other funny characters in exactly the way you would in the 
shell (which isn't surprising since CGI.pm uses "shellwords.pl" internally). 
This lets you do this sort of thing: <PRE>    my_script.pl 'name 1=I am a long value' name\ 2=two\ words
</PRE>
<P>If you run a script that uses CGI.pm from the command line and fail to 
provide it with any arguments, it will print out the line <PRE>(offline mode: enter name=value pairs on standard input)
</PRE>then appear to hang. In fact, the library is waiting for you to give it 
some parameters to process on its standard input. If you want to give it some 
parameters, enter them as shown above, then indicate that you're finished with 
input by pressing ^D (^Z on NT/DOS systems). If you don't want to give CGI.pm 
parameters, just press ^D. 
<P>You can suppress this behavior in any of the following ways: 
<DL>
  <DT>1. Call the script with an empty parameter. 
  <DD>Example: <PRE>      my_script.pl ''
      </PRE>
  <P></P>
  <DT>2. Redirect standard input from /dev/null or an empty file. 
  <DD>Example: <PRE>      my_script.pl &lt;/dev/null
      </PRE>
  <P></P>
  <DT>3. Include "-no_debug" in the list of symbols to import on the "use" line. 

  <DD>Example: <PRE>      use CGI qw/:standard -no_debug/;
      </PRE></DD></DL><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<H3><A name=dumping>Dumping Out All The Name/Value Pairs</A></H3>The 
<STRONG>Dump()</STRONG> method produces a string consisting of all the query's 
name/value pairs formatted nicely as a nested list. This is useful for debugging 
purposes: <PRE>   print $query-&gt;Dump
</PRE>Produces something that looks like this: <PRE>   &lt;UL&gt;
   &lt;LI&gt;name1
       &lt;UL&gt;
       &lt;LI&gt;value1
       &lt;LI&gt;value2
       &lt;/UL&gt;
   &lt;LI&gt;name2
       &lt;UL&gt;
       &lt;LI&gt;value1
       &lt;/UL&gt;
   &lt;/UL&gt;
</PRE>You can achieve the same effect by incorporating the CGI object directly 
into a string, as in: <PRE>   print "&lt;H2&gt;Current Contents:&lt;/H2&gt;\n$query\n";
</PRE>
<HR>

<H2><A name=environment>HTTP Session Variables</A></H2>Some of the more useful 
environment variables can be fetched through this interface. The methods are as 
follows: 
<DL>
  <DT>Accept() 
  <DD>Return a list of MIME types that the remote browser accepts. If you give 
  this method a single argument corresponding to a MIME type, as in 
  <CODE>$query-&gt;Accept('text/html')</CODE>, it will return a floating point 
  value corresponding to the browser's preference for this type from 0.0 (don't 
  want) to 1.0. Glob types (e.g. text/*) in the browser's accept list are 
  handled correctly. Note the capitalization of the initial letter. This avoids 
  conflict with the Perl built-in accept(). 
  <DT>auth_type() 
  <DD>Return the authorization type, if protection is active. Example "Basic". 
  <DT><A name=raw_cookie>raw_cookie()</A> 
  <DD>Returns the "magic cookie" maintained by Netscape 1.1 and higher in a raw 
  state. You'll probably want to use <A 
  href="http://stein.cshl.org/WWW/software/CGI/cookies">cookie()</A> instead, 
  which gives you a high-level interface to the cookie functions. Called with no 
  parameters, raw_cookie() returns the entire cookie structure, which may 
  consist of several cookies appended together (you can recover individual 
  cookies by splitting on the "; " sequence. Called with the name of a cookie, 
  returns the unescaped value of the cookie as set by the server. This may be 
  useful for retrieving cookies that your script did not set. 
  <DT><A name=path_info>path_info()</A> 
  <DD>Returns additional path information from the script URL. E.G. fetching 
  <CODE>/cgi-bin/your_script/additional/stuff</CODE> will result in 
  <CODE>$query-&gt;path_info()</CODE> returning 
  <CODE>"/additional/stuff"</CODE>. In addition to reading the path information, 
  you can set it by giving path_info() an optional string argument. The argument 
  is expected to begin with a "/". If not present, one will be added for you. 
  The new path information will be returned by subsequent calls to path_info(), 
  and will be incorporated into the URL generated by self_url(). 
  <DT>path_translated() 
  <DD>As per path_info() but returns the additional path information translated 
  into a physical path, e.g. 
  <CODE>"/usr/local/etc/httpd/htdocs/additional/stuff"</CODE>. You cannot change 
  the path_translated, nor will setting the additional path information change 
  this value. The reason for this restriction is that the translation of path 
  information into a physical path is ordinarily done by the server in a layer 
  that is inaccessible to CGI scripts. 
  <DT>query_string() 
  <DD>Returns a query string suitable for maintaining state. 
  <DT>referer() 
  <DD>Return the URL of the page the browser was viewing prior to fetching your 
  script. Not available for all browsers. 
  <DT>remote_addr() 
  <DD>Return the dotted IP address of the remote host. 
  <DT>remote_ident() 
  <DD>Return the identity-checking information from the remote host. Only 
  available if the remote host has the identd daemon turned on. 
  <DT>remote_host() 
  <DD>Returns either the remote host name or IP address. if the former is 
  unavailable. 
  <DT>remote_user() 
  <DD>Return the name given by the remote user during password authorization. 
  <DT>request_method() 
  <DD>Return the HTTP method used to request your script's URL, usually one of 
  <CODE>GET, POST,</CODE> or <CODE>HEAD</CODE>. 
  <DT>script_name() 
  <DD>Return the script name as a partial URL, for self-refering scripts. 
  <DT>server_name() 
  <DD>Return the name of the WWW server the script is running under. 
  <DT>server_software() 
  <DD>Return the name and version of the server software. 
  <DT>virtual_host() 
  <DD>When using the virtual host feature of some servers, returns the name of 
  the virtual host the browser is accessing. 
  <DT>server_port() 
  <DD>Return the communications port the server is using. 
  <DT>user_agent() 
  <DD>Returns the identity of the remote user's browser software, e.g. 
  "Mozilla/1.1N (Macintosh; I; 68K)" 
  <DT>user_name() 
  <DD>Attempts to obtain the remote user's name, using a variety of environment 
  variables. This only works with older browsers such as Mosaic. Netscape does 
  not reliably report the user name! 
  <DT>http() 
  <DD>Called with no arguments returns the list of HTTP environment variables, 
  including such things as HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and 
  HTTP_ACCEPT_CHARSET, corresponding to the like-named HTTP header fields in the 
  request. Called with the name of an HTTP header field, returns its value. 
  Capitalization and the use of hyphens versus underscores are not significant. 
  <P>For example, all three of these examples are equivalent: <PRE>   $requested_language = $q-&gt;http('Accept-language');
   $requested_language = $q-&gt;http('Accept_language');
   $requested_language = $q-&gt;http('HTTP_ACCEPT_LANGUAGE');
</PRE>
  <DT>https() 
  <DD>The same as http(), but operates on the HTTPS environment variables 
  present when the SSL protocol is in effect. Can be used to determine whether 
  SSL is turned on. </DD></DL><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<HR>

<H2><A name=cookies>HTTP Cookies</A></H2>Netscape browsers versions 1.1 and 
higher, and all versions of Internet Explorer support a so-called "cookie" 
designed to help maintain state within a browser session. CGI.pm has several 
methods that support cookies. 
<P>A cookie is a name=value pair much like the named parameters in a CGI query 
string. CGI scripts create one or more cookies and send them to the browser in 
the HTTP header. The browser maintains a list of cookies that belong to a 
particular Web server, and returns them to the CGI script during subsequent 
interactions. 
<P>In addition to the required name=value pair, each cookie has several optional 
attributes: 
<DL>
  <DT>an expiration time 
  <DD>This is a time/date string (in a special GMT format) that indicates when a 
  cookie expires. The cookie will be saved and returned to your script until 
  this expiration date is reached if the user exits the browser and restarts it. 
  If an expiration date isn't specified, the cookie will remain active until the 
  user quits the browser. 
  <P>Negative expiration times (e.g. "-1d") cause some browsers to delete the 
  cookie from its persistent store. This is a poorly documented feature. 
  <P></P>
  <DT>a domain 
  <DD>This is a partial or complete domain name for which the cookie is valid. 
  The browser will return the cookie to any host that matches the partial domain 
  name. For example, if you specify a domain name of ".capricorn.com", then the 
  browser will return the cookie to Web servers running on any of the machines 
  "www.capricorn.com", "www2.capricorn.com", "feckless.capricorn.com", etc. 
  Domain names must contain at least two periods to prevent attempts to match on 
  top level domains like ".edu". If no domain is specified, then the browser 
  will only return the cookie to servers on the host the cookie originated from.
  <P></P>
  <DT>a path 
  <DD>If you provide a cookie path attribute, the browser will check it against 
  your script's URL before returning the cookie. For example, if you specify the 
  path "/cgi-bin", then the cookie will be returned to each of the scripts 
  "/cgi-bin/tally.pl", "/cgi-bin/order.pl", and 
  "/cgi-bin/customer_service/complain.pl", but not to the script 
  "/cgi-private/site_admin.pl". By default, path is set to "/", which causes the 
  cookie to be sent to any CGI script on your site. 
  <DT>a "secure" flag 
  <DD>If the "secure" attribute is set, the cookie will only be sent to your 
  script if the CGI request is occurring on a secure channel, such as SSL. 
</DD></DL>The interface to HTTP cookies is the <STRONG>cookie()</STRONG> method: 
<PRE>    $cookie = $query-&gt;cookie(-name=&gt;'sessionID',
			     -value=&gt;'xyzzy',
			     -expires=&gt;'+1h',
			     -path=&gt;'/cgi-bin/database',
			     -domain=&gt;'.capricorn.org',
			     -secure=&gt;1);
    print $query-&gt;header(-cookie=&gt;$cookie);
</PRE><STRONG>cookie()</STRONG> creates a new cookie. Its parameters include: 
<DL>
  <DT><STRONG>-name</STRONG> 
  <DD>The name of the cookie (required). This can be any string at all. Although 
  Netscape limits its cookie names to non-whitespace alphanumeric characters, 
  CGI.pm removes this restriction by escaping and unescaping cookies behind the 
  scenes.
  <P></P>
  <DT><STRONG>-value</STRONG> 
  <DD>The value of the cookie. This can be any scalar value, array reference, or 
  even associative array reference. For example, you can store an entire 
  associative array into a cookie this way: <PRE>	$cookie=$query-&gt;cookie(-name=&gt;'family information',
                               -value=&gt;\%childrens_ages);
</PRE>
  <DT><STRONG>-path</STRONG> 
  <DD>The optional partial path for which this cookie will be valid, as 
  described above.
  <P></P>
  <DT><STRONG>-domain</STRONG> 
  <DD>The optional partial domain for which this cookie will be valid, as 
  described above. 
  <DT><STRONG>-expires</STRONG> 
  <DD>The optional expiration date for this cookie. The format is as described 
  in the section on the <STRONG>header()</STRONG> method: <PRE>	"+1h"  one hour from now
      </PRE>
  <DT><STRONG>-secure</STRONG> 
  <DD>If set to true, this cookie will only be used within a secure SSL session. 
  </DD></DL>The cookie created by <STRONG>cookie()</STRONG> must be incorporated 
into the HTTP header within the string returned by the <A 
href="http://stein.cshl.org/WWW/software/CGI/#header">header()</A> method: <PRE>	print $query-&gt;header(-cookie=&gt;$my_cookie);
</PRE>To create multiple cookies, give header() an array reference: <PRE>	$cookie1 = $query-&gt;cookie(-name=&gt;'riddle_name',
                                  -value=&gt;"The Sphynx's Question");
        $cookie2 = $query-&gt;cookie(-name=&gt;'answers',
                                  -value=&gt;\%answers);
        print $query-&gt;header(-cookie=&gt;[$cookie1,$cookie2]);
</PRE>To retrieve a cookie, request it by name by calling cookie() method 
without the <STRONG>-value</STRONG> parameter: <PRE>	use CGI;
	$query = new CGI;
	%answers = $query-&gt;cookie('answers');
	# $query-&gt;cookie(-name=&gt;'answers') works too!
</PRE>To retrieve the names of all cookies passed to your script, call 
<STRONG>cookie()</STRONG> without any parameters. This allows you to iterate 
through all cookies: <PRE>	foreach $name ($query-&gt;cookie()) {
            print $query-&gt;cookie($name);
        }
</PRE>
<P>The cookie and CGI namespaces are separate. If you have a parameter named 
'answers' and a cookie named 'answers', the values retrieved by param() and 
cookie() are independent of each other. However, it's simple to turn a CGI 
parameter into a cookie, and vice-versa: <PRE>   # turn a CGI parameter into a cookie
   $c=$q-&gt;cookie(-name=&gt;'answers',-value=&gt;[$q-&gt;param('answers')]);
   # vice-versa
   $q-&gt;param(-name=&gt;'answers',-value=&gt;[$q-&gt;cookie('answers')]);
</PRE>
<P>See the <A 
href="http://stein.cshl.org/WWW/software/CGI/examples/cookie.cgi">cookie.cgi</A> 
example script for some ideas on how to use cookies effectively. 
<P><STRONG>NOTE:</STRONG> There are some limitations on cookies. Here is what 
RFC2109, section 6.3, states: <PRE>   Practical user agent implementations have limits on the number and
   size of cookies that they can store.  In general, user agents' cookie
   support should have no fixed limits.  They should strive to store as
   many frequently-used cookies as possible.  Furthermore, general-use
   user agents should provide each of the following minimum capabilities
   individually, although not necessarily simultaneously:

      * at least 300 cookies

      * at least 4096 bytes per cookie (as measured by the size of the
        characters that comprise the cookie non-terminal in the syntax
        description of the Set-Cookie header)

      * at least 20 cookies per unique host or domain name

   User agents created for specific purposes or for limited-capacity
   devices should provide at least 20 cookies of 4096 bytes, to ensure
   that the user can interact with a session-based origin server.

   The information in a Set-Cookie response header must be retained in
   its entirety.  If for some reason there is inadequate space to store
   the cookie, it must be discarded, not truncated.

   Applications should use as few and as small cookies as possible, and
   they should cope gracefully with the loss of a cookie.
</PRE>Unfortunately, some browsers appear to have limits that are more 
restrictive than those given in the RFC. If you need to store a lot of 
information, it's probably better to create a unique session ID, store it in a 
cookie, and use the session ID to locate an external file/database saved on the 
server's side of the connection. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=frames>Support for Frames</A></H2>CGI.pm contains support for <A 
href="http://home.netscape.com/assist/net_sites/frames.html">HTML frames</A>, a 
feature of Netscape 2.0 and higher, and Internet Explorer 3.0 and higher. Frames 
are supported in two ways: 
<OL>
  <LI>You can provide the name of a new or preexisting frame in the startform() 
  and start_multipart_form() methods using the <CODE>-target</CODE> parameter. 
  When the form is submitted, the output will be redirected to the indicated 
  frame: <PRE>      print $query-&gt;start_form(-target=&gt;'result_frame');
      </PRE>
  <LI>You can direct the output of a script into a new window or into a 
  preexisting named frame by providing the name of the frame as a 
  <CODE>-target</CODE> argument in the header method. For example, the following 
  code will pop up a new window and display the script's output: <PRE>      $query = new CGI;
      print $query-&gt;header(-target=&gt;'_blank');
      </PRE>This feature is a non-standard extension to HTTP which is 
  supported by Netscape browsers, but <B>not by Internet Explorer</B>. 
</LI></OL>Using frames effectively can be tricky. To create a proper frameset in 
which the query and response are displayed side-by-side requires you to divide 
the script into three functional sections. The first section should create the 
&lt;frameset&gt; declaration and exit. The second section is responsible for 
creating the query form and directing it into the one frame. The third section 
is responsible for creating the response and directing it into a different 
frame. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/examples/">The examples 
directory</A> contains a script called <A 
href="http://stein.cshl.org/WWW/software/CGI/examples/popup.cgi">popup.cgi</A> 
that demonstrates a simple popup window. <A 
href="http://stein.cshl.org/WWW/software/CGI/examples/frameset.cgi">frameset.cgi</A> 
provides a skeleton script for creating side-by-side query/result frame sets. 
<HR>

<H2><A name=javascripting>Support for JavaScript</A></H2>Netscape versions 2.0 
and higher incorporate an interpreted language called JavaScript. Internet 
Explorer, 3.0 and higher, supports a closely-related dialect called JScript. 
JavaScript isn't the same as Java, and certainly isn't at all the same as Perl, 
which is a great pity. JavaScript allows you to programatically change the 
contents of fill-out forms, create new windows, and pop up dialog box from 
within Netscape itself. From the point of view of CGI scripting, JavaScript is 
quite useful for validating fill-out forms prior to submitting them. 
<P>You'll need to know JavaScript in order to use it. The <A 
href="http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/">Netscape 
JavaScript manual</A> contains a good tutorial and reference guide to the 
JavaScript programming language. 
<P>The usual way to use JavaScript is to define a set of functions in a 
&lt;SCRIPT&gt; block inside the HTML header and then to register event handlers 
in the various elements of the page. Events include such things as the mouse 
passing over a form element, a button being clicked, the contents of a text 
field changing, or a form being submitted. When an event occurs that involves an 
element that has registered an event handler, its associated JavaScript code 
gets called. 
<P>The elements that can register event handlers include the &lt;BODY&gt; of an 
HTML document, hypertext links, all the various elements of a fill-out form, and 
the form itself. There are a large number of events, and each applies only to 
the elements for which it is relevant. Here is a partial list: 
<DL>
  <DT><B>onLoad</B> 
  <DD>The browser is loading the current document. Valid in: 
  <UL>
    <LI>The HTML &lt;BODY&gt; section only. </LI></UL>
  <DT><B>onUnload</B> 
  <DD>The browser is closing the current page or frame. Valid for: 
  <UL>
    <LI>The HTML &lt;BODY&gt; section only. </LI></UL>
  <DT><B>onSubmit</B> 
  <DD>The user has pressed the submit button of a form. This event happens just 
  before the form is submitted, and your function can return a value of 
  <EM>false</EM> in order to abort the submission. Valid for: 
  <UL>
    <LI>Forms only. </LI></UL>
  <DT><B>onClick</B> 
  <DD>The mouse has clicked on an item in a fill-out form. Valid for: 
  <UL>
    <LI>Buttons (including submit, reset, and image buttons) 
    <LI>Checkboxes 
    <LI>Radio buttons </LI></UL>
  <DT><B>onChange</B> 
  <DD>The user has changed the contents of a field. Valid for: 
  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields 
    <LI>Popup Menus 
    <LI>Scrolling lists </LI></UL>
  <DT><B>onFocus</B> 
  <DD>The user has selected a field to work with. Valid for: 
  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields 
    <LI>Popup Menus 
    <LI>Scrolling lists </LI></UL>
  <DT><B>onBlur</B> 
  <DD>The user has deselected a field (gone to work somewhere else). Valid for: 
  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields 
    <LI>Popup Menus 
    <LI>Scrolling lists </LI></UL>
  <DT><B>onSelect</B> 
  <DD>The user has changed the part of a text field that is selected. Valid for: 

  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields </LI></UL>
  <DT><B>onMouseOver</B> 
  <DD>The mouse has moved over an element. 
  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields 
    <LI>Popup Menus 
    <LI>Scrolling lists </LI></UL>
  <DT><B>onMouseOut</B> 
  <DD>The mouse has moved off an element. 
  <UL>
    <LI>Text fields 
    <LI>Text areas 
    <LI>Password fields 
    <LI>File fields 
    <LI>Popup Menus 
    <LI>Scrolling lists </LI></UL></DD></DL>In order to register a JavaScript event 
handler with an HTML element, just use the event name as a parameter when you 
call the corresponding CGI method. For example, to have your 
<CODE>validateAge()</CODE> JavaScript code executed every time the textfield 
named "age" changes, generate the field like this: <PRE>   print $q-&gt;textfield(-name=&gt;'age',-onChange=&gt;"validateAge(this)");
</PRE>This example assumes that you've already declared the 
<CODE>validateAge()</CODE> function by incorporating it into a &lt;SCRIPT&gt; 
block. The CGI.pm <A 
href="http://stein.cshl.org/WWW/software/CGI/#html">start_html()</A> method 
provides a convenient way to create this section. 
<P>Similarly, you can create a form that checks itself over for consistency and 
alerts the user if some essential value is missing by creating it this way: <PRE>   print $q-&gt;startform(-onSubmit=&gt;"validateMe(this)");
</PRE>See the <A 
href="http://stein.cshl.org/WWW/software/CGI/examples/javascript.cgi">javascript.cgi</A> 
script for a demonstration of how this all works. 
<P>The JavaScript "standard" is still evolving, which means that new handlers 
may be added in the future, or may be present in some browsers and not in 
others. You do not need to wait for a new version of CGI.pm to use new event 
handlers. Just like any other tag attribute they will produce syntactically 
correct HTML. For instance, if Microsoft invents a new event handler called 
<STRONG>onInterplanetaryDisaster</STRONG>, you can install a handler for it 
with: 
<BLOCKQUOTE><PRE>print button(-name=&gt;'bail out',-onInterPlaneteryDisaster=&gt;"alert('uh oh')");
</PRE></BLOCKQUOTE><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<HR>

<H2><A name=stylesheets>Limited Support for Cascading Style 
Sheets</A></H2>CGI.pm has limited support for HTML3's cascading style sheets 
(css). To incorporate a stylesheet into your document, pass the 
<STRONG>start_html()</STRONG> method a <STRONG>-style</STRONG> parameter. The 
value of this parameter may be a scalar, in which case it is incorporated 
directly into a &lt;STYLE&gt; section, or it may be a hash reference. In the 
latter case you should provide the hash with one or more of 
<STRONG>-src</STRONG> or <STRONG>-code</STRONG>. <STRONG>-src</STRONG> points to 
a URL where an externally-defined stylesheet can be found. 
<STRONG>-code</STRONG> points to a scalar value to be incorporated into a 
&lt;STYLE&gt; section. Style definitions in <STRONG>-code</STRONG> override 
similarly-named ones in <STRONG>-src</STRONG>, hence the name "cascading." 
<P>You may also specify the MIME type of the stylesheet by including an optional 
<STRONG>-type</STRONG> parameter in the hash pointed to by 
<STRONG>-style</STRONG>. If not specified, the type defaults to 'text/css'. 
<P>To refer to a style within the body of your document, add the 
<STRONG>-class</STRONG> parameter to any HTML element: 
<BLOCKQUOTE><PRE>print h1({-class=&gt;'Fancy'},'Welcome to the Party');
</PRE></BLOCKQUOTE>Or define styles on the fly with the <STRONG>-style</STRONG> 
parameter: 
<BLOCKQUOTE><PRE>print h1({-style=&gt;'Color: red;'},'Welcome to Hell');
</PRE></BLOCKQUOTE>You may also use the new <STRONG>span()</STRONG> element to 
apply a style to a section of text: 
<BLOCKQUOTE><PRE>print span({-style=&gt;'Color: red;'},
	       h1('Welcome to Hell'),
	       "Where did that handbasket get to?"
          );
</PRE></BLOCKQUOTE>Note that you must import the ":html3" definitions to get the 
<STRONG>span()</STRONG> and <STRONG>style()</STRONG> methods. 
<P>You won't be able to do much with this unless you understand the CSS 
specification. A more intuitive subclassable library for cascading style sheets 
in Perl is in the works, but until then, please read the CSS specification at <A 
href="http://www.w3.org/pub/WWW/Style/">http://www.w3.org/pub/WWW/Style/</A> to 
find out how to use these features. Here's a final example to get you started. 
<BLOCKQUOTE><PRE>use CGI qw/:standard :html3/;

#here's a stylesheet incorporated directly into the page
$newStyle=&lt;&lt;END;
&lt;!-- 
    P.Tip {
	margin-right: 50pt;
	margin-left: 50pt;
        color: red;
    }
    P.Alert {
	font-size: 30pt;
        font-family: sans-serif;
      color: red;
    }
--&gt;
END
print header();
print start_html( -title=&gt;'CGI with Style',
                  -style=&gt;{-src=&gt;'http://www.capricorn.com/style/st1.css',
                  -code=&gt;$newStyle}
	         );
print h1('CGI with Style'),
      p({-class=&gt;'Tip'},
        "Better read the cascading style sheet spec before playing with this!"
        ),
      span({-style=&gt;'color: magenta'},"Look Mom, no hands!",
        p(),
        "Whooo wee!"
      );
print end_html;
</PRE></BLOCKQUOTE>
<P>Pass an array reference to <B>-style</B> in order to incorporate multiple 
stylesheets into your document. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=nph>Using NPH Scripts</A></H2>NPH, or "no-parsed-header", scripts 
bypass the server completely by sending the complete HTTP header directly to the 
browser. This has slight performance benefits, but is of most use for taking 
advantage of HTTP extensions that are not directly supported by your server, 
such as server push and PICS headers. 
<P>Servers use a variety of conventions for designating CGI scripts as NPH. IIS 
and many Unix servers look at the beginning of the script's name for the prefix 
"nph-". 
<P>CGI.pm supports NPH scripts with a special NPH mode. When in this mode, 
CGI.pm will output the necessary extra header information when the 
<CODE>header()</CODE> and <CODE>redirect()</CODE> methods are called. 
<P><STRONG>Important:</STRONG> If you use the Microsoft Internet Information 
Server, you <EM>must</EM> designate your script as an NPH script. Otherwise many 
of CGI.pm's features, such as redirection and the ability to output non-HTML 
files, will fail. However, after applying Service Pack 6, NPH scripts <EM>do not 
work at all</EM> on IIS without a special patch from Microsoft. See <A 
href="http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP">Knowledgebase 
article Q280/3/31 Non-Parsed Headers Stripped From CGI Applications That Have 
nph- Prefix in Name</A> 
<P>There are a number of ways to put CGI.pm into NPH mode: 
<DL>
  <DT>In the <STRONG>use</STRONG> statement: 
  <DD>Simply add "-nph" to the list of symbols to be imported into your script: 
  <BLOCKQUOTE><PRE>      use CGI qw(:standard -nph)
      </PRE></BLOCKQUOTE>
  <P></P>
  <DT>By calling the <STRONG>nph()</STRONG> method: 
  <DD>Call <STRONG>nph()</STRONG> with a non-zero parameter at any point after 
  using CGI.pm in your program. 
  <BLOCKQUOTE><PRE>      CGI-&gt;nph(1)
      </PRE></BLOCKQUOTE>
  <P></P>
  <DT>By using <STRONG>-nph</STRONG> parameters in the <STRONG>header()</STRONG> 
  and <STRONG>redirect()</STRONG> statements: 
  <DD>
  <BLOCKQUOTE><PRE>      print $q-&gt;header(-nph=&gt;1);
      </PRE></BLOCKQUOTE></DD></DL>
<HR>

<H2><A name=advanced>Advanced Techniques</A></H2>
<H3>A Script that Saves Some Information to a File and Restores It</H3>This 
script will save its state to a file of the user's choosing when the "save" 
button is pressed, and will restore its state when the "restore" button is 
pressed. Notice that <EM>it's very important to check the file name</EM> for 
shell metacharacters so that the script doesn't inadvertently open up a command 
or overwrite someone's file. For this to work, the script's current directory 
must be writable by "nobody". <PRE>#!/usr/local/bin/perl

use CGI;
$query = new CGI;

print $query-&gt;header;
print $query-&gt;start_html("Save and Restore Example");
print "&lt;H1&gt;Save and Restore Example&lt;/H1&gt;\n";

# Here's where we take action on the previous request
&amp;save_parameters($query)              if $query-&gt;param('action') eq 'save';
$query = &amp;restore_parameters($query)  if $query-&gt;param('action') eq 'restore';

# Here's where we create the form
print $query-&gt;startform;
print "Popup 1: ",$query-&gt;popup_menu('popup1',['eenie','meenie','minie']),"\n";
print "Popup 2: ",$query-&gt;popup_menu('popup2',['et','lux','perpetua']),"\n";
print "&lt;P&gt;";
print "Save/restore state from file: ",$query-&gt;textfield('savefile','state.sav'),"\n";
print "&lt;P&gt;";
print $query-&gt;submit('action','save'),$query-&gt;submit('action','restore');
print $query-&gt;submit('action','usual query');
print $query-&gt;endform;

# Here we print out a bit at the end
print $query-&gt;end_html;

sub save_parameters {
    local($query) = @_;
    local($filename) = &amp;clean_name($query-&gt;param('savefile'));
    if (open(FILE,"&gt;$filename")) {
	$query-&gt;save(FILE);
	close FILE;
	print "&lt;STRONG&gt;State has been saved to file $filename&lt;/STRONG&gt;\n";
    } else {
	print "&lt;STRONG&gt;Error:&lt;/STRONG&gt; couldn't write to file $filename: $!\n";
    }
}

sub restore_parameters {
    local($query) = @_;
    local($filename) = &amp;clean_name($query-&gt;param('savefile'));
    if (open(FILE,$filename)) {
	$query = new CGI(FILE);  # Throw out the old query, replace it with a new one
	close FILE;
	print "&lt;STRONG&gt;State has been restored from file $filename&lt;/STRONG&gt;\n";
    } else {
	print "&lt;STRONG&gt;Error:&lt;/STRONG&gt; couldn't restore file $filename: $!\n";
    }
    return $query;
}


# Very important subroutine -- get rid of all the naughty
# metacharacters from the file name. If there are, we
# complain bitterly and die.
sub clean_name {
   local($name) = @_;
   unless ($name=~/^[\w\._-]+$/) {
      print "&lt;STRONG&gt;$name has naughty characters.  Only ";
      print "alphanumerics are allowed.  You can't use absolute names.&lt;/STRONG&gt;";
      die "Attempt to use naughty characters";
   }
   return $name;
}
</PRE>If you use the CGI save() and restore() methods a lot, you might be 
interested in the <CITE>Boulderio</CITE> file format. It's a way of transferring 
semi-strucured data from the standard output of one program to the standard 
input of the next. It comes with a simple Perl database that allows you to store 
and retrieve records from a DBM or DB_File database, and is compatible with the 
format used by save() and restore(). You can get more information on Boulderio 
from: 
<BLOCKQUOTE><PRE><A href="http://stein.cshl.org/software/boulder/">http://stein.cshl.org/software/boulder/</A>
</PRE></BLOCKQUOTE>
<H3>A Script that Uses Self-Referencing URLs to Jump to Internal 
Links</H3>(Without losing form information). 
<P>Many people have experienced problems with internal links on pages that have 
forms. Jumping around within the document causes the state of the form to be 
reset. A partial solution is to use the self_url() method to generate a link 
that preserves state information. This script illustrates how this works. <PRE>#!/usr/local/bin/perl

use CGI;
$query = new CGI;

# We generate a regular HTML file containing a very long list
# and a popup menu that does nothing except to show that we
# don't lose the state information.
print $query-&gt;header;
print $query-&gt;start_html("Internal Links Example");
print "&lt;H1&gt;Internal Links Example&lt;/H1&gt;\n";

print "&lt;A NAME=\"start\"&gt;&lt;/A&gt;\n"; # an anchor point at the top

# pick a default starting value;
$query-&gt;param('amenu','FOO1') unless $query-&gt;param('amenu');

print $query-&gt;startform;
print $query-&gt;popup_menu('amenu',[('FOO1'..'FOO9')]);
print $query-&gt;submit,$query-&gt;endform;

# We create a long boring list for the purposes of illustration.
$myself = $query-&gt;self_url;
print "&lt;OL&gt;\n";
for (1..100) {
    print qq{&lt;LI&gt;List item #$_&lt;A HREF="$myself#start"&gt;Jump to top&lt;/A&gt;\n};
}
print "&lt;/OL&gt;\n";

print $query-&gt;end_html;
</PRE>
<H3>Multiple forms on the same page</H3>There's no particular trick to this. 
Just remember to close one form before you open another one. You can reuse the 
same query object or create a new one. Either technique works. 
<P>There is, however, a problem with maintaining the states of multiple forms. 
Because the browser only sends your script the parameters from the form in which 
the submit button was pressed, the state of all the other forms will be lost. 
One way to get around this, suggested in this example, is to use hidden fields 
to pass as much information as possible regardless of which form the user 
submits. <PRE>#!/usr/local/bin/perl
use CGI;

$query=new CGI;
print $query-&gt;header;
print $query-&gt;start_html('Multiple forms');
print "&lt;H1&gt;Multiple forms&lt;/H1&gt;\n";

# form 1
print "&lt;HR&gt;\n";
print $query-&gt;startform;
print $query-&gt;textfield('text1'),$query-&gt;submit('submit1');
print $query-&gt;hidden('text2');  # pass information from the other form
print $query-&gt;endform;
print "&lt;HR&gt;\n";

# form 2
print $query-&gt;startform;
print $query-&gt;textfield('text2'),$query-&gt;submit('submit2');
print $query-&gt;hidden('text1');  # pass information from the other form
print $query-&gt;endform;
print "&lt;HR&gt;\n";
print $query-&gt;end_html;
</PRE>
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=subclassing>Subclassing CGI.pm</A></H2>CGI.pm uses various tricks to 
work in both an object-oriented and function-oriented fashion. It uses even more 
tricks to load quickly, despite the fact that it is a humungous module. These 
tricks may get in your way when you attempt to subclass CGI.pm. 
<P>If you use standard subclassing techniques and restrict yourself to using 
CGI.pm and its subclasses in the object-oriented manner, you'll have no 
problems. However, if you wish to use the function-oriented calls with your 
subclass, follow this model: 
<BLOCKQUOTE><PRE>package MySubclass;
use vars qw(@ISA $VERSION);
require CGI;
@ISA = qw(CGI);
$VERSION = 1.0;

$CGI::DefaultClass = __PACKAGE__;
$AutoloadClass = 'CGI';

sub new {
   ....
}
1;
</PRE></BLOCKQUOTE>The first special trick is to set the CGI package variable 
$CGI::DefaultClass to the name of the module you are defining. If you are using 
perl 5.004 or higher, you can use the special token "__PACKAGE__" to retrieve 
the name of the current module. Otherwise, just hard code the name of the 
module. This variable tells CGI what type of default object to create when 
called in the function-oriented manner. 
<P>The second trick is to set the package variable $AutoloadClass to the string 
"CGI". This tells the CGI autoloader where to look for functions that are not 
defined. If you wish to override CGI's autoloader, set this to the name of your 
own package. 
<P>More information on extending CGI.pm can be found in my new book, <CITE>The 
Official Guide to CGI.pm</CITE>, which was published by John Wiley &amp; Sons in 
April 1998. Check out the book's <A 
href="http://www.wiley.com/compbooks/stein/">Web site</A>, which contains 
multiple useful coding examples. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=mod_perl>Using CGI.pm with mod_perl and FastCGI</A></H2>
<H3>FastCGI</H3><A href="http://www.fastcgi.com/">FastCGI</A> is a protocol 
invented by OpenMarket that markedly speeds up CGI scripts under certain 
circumstances. It works by opening up the script at server startup time and 
redirecting the script's IO to a Unix domain socket. Every time a new CGI 
request comes in, the script is passed new parameters to work on. This allows 
the script to perform all its time-consuming operations at initialization time 
(including loading CGI.pm!) and then respond quickly to new requests. 
<P>FastCGI modules are available for the Apache and NCSA servers as well as for 
OpenMarket's own server. In order to use FastCGI with Perl you have to run a 
specially-modified version of the Perl interpreter. Precompiled Binaries and a 
patch kit are all available on OpenMarket's FastCGI web site. 
<P>To use FastCGI with CGI.pm, change your scripts as follows: 
<H4>Old Script</H4>
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl
use CGI qw(:standard);
print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),  
      end_html;
</PRE></BLOCKQUOTE>
<H4>New Script</H4>
<BLOCKQUOTE><PRE>#!/usr/local/fcgi/bin/perl
use CGI::Fast qw(:standard);

# Do time-consuming initialization up here.
while (new CGI::Fast) {
   print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),  
      end_html;
}
</PRE></BLOCKQUOTE>That's all there is to it. The param() method, 
form-generation, HTML shortcuts, etc., all work the way you expect. 
<H3>mod_perl</H3><A href="http://www.perl.com/CPAN/modules/Apache/">mod_perl</A> 
is a module for the Apache Web server that embeds a Perl interpreter into the 
Web server. It can be run in either of two modes: 
<OL>
  <LI>Server launches a new Perl interpreter every time it needs to interpret a 
  Perl script. This speeds CGI scripts significantly because there's no overhead 
  for launching a new Perl process. 
  <LI>A "fast" mode in which the server launches your script at initialization 
  time. You can load all your favorite modules (like CGI.pm!) at initialization 
  time, greatly speeding things up. </LI></OL>CGI.pm works with mod_perl, versions 
0.95 and higher. If you use Perl 5.003_93 or higher, your scripts should run 
without any modifications. Users with earlier versions of Perl should use the 
<CITE>CGI::Apache</CITE> module instead. This example shows the change needed: 
<H4>Old Script</H4>
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl
use CGI qw(:standard);
print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),  
      end_html;
</PRE></BLOCKQUOTE>
<H4>New Script</H4>
<BLOCKQUOTE><PRE>#!/usr/bin/perl
use CGI::Apache qw(:standard);

print header,
    start_html("CGI Script"),
    h1("CGI Script"),
    "Not much to see here",
    hr,
    address(a({href=&gt;'/'},"home page"),  
    end_html;
}
</PRE></BLOCKQUOTE><STRONG>Configuration note:</STRONG> When using CGI.pm with 
mod_perl it is <STRONG>not</STRONG> necessary to enable either the 
<TT>PerlSendHeader</TT> or <TT>PerlSetupEnv</TT> directives. This is handled 
automatically by CGI.pm and by Apache::Registry. 
<P>mod_perl comes with a small wrapper library named <CITE>CGI::Switch</CITE> 
that selects dynamically between using CGI and CGI::Apache. This library is no 
longer needed. However users of CGI::Switch can continue to use it without risk. 
Note that the "simple" interface to the CGI.pm functions does not work with 
CGI::Switch. You'll have to use the object-oriented versions (or use the sfio 
version of Perl!) 
<P>If you use CGI.pm in many of your mod_perl scripts, you may want to preload 
CGI.pm and its methods at server startup time. To do this, add the following 
line to httpd.conf: 
<BLOCKQUOTE><PRE>PerlScript /home/httpd/conf/startup.pl
</PRE></BLOCKQUOTE>Create the file /home/httpd/conf/startup.pl and put in it all 
the modules you want to load. Include CGI.pm among them and call its <A 
href="http://stein.cshl.org/WWW/software/CGI/#compile">compile()</A> method to 
precompile its autoloaded methods. 
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl

use CGI ();
CGI-&gt;compile(':all');
</PRE></BLOCKQUOTE>Change the path to the startup script according to your 
preferences. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=migrating>Migrating from cgi-lib.pl</A></H2>To make it easier to 
convert older scripts that use cgi-lib.pl, CGI.pm provides a 
<STRONG>CGI::ReadParse()</STRONG> call that is compatible with cgi-lib.pl's 
<STRONG>ReadParse()</STRONG> subroutine. 
<P>When you call ReadParse(), CGI.pm creates an associative array named 
<CODE>%in</CODE> that contains the named CGI parameters. Multi-valued parameters 
are separated by "\0" characters in exactly the same way cgi-lib.pl does it. The 
function result is the number of parameters parsed. You can use this to 
determine whether the script is being called from a fill out form or not. 
<P>To port an old script to CGI.pm, you have to make just two changes: 
<H4>Old Script</H4><PRE>    require "cgi-lib.pl";
    ReadParse();
    print "The price of your purchase is $in{price}.\n";
</PRE>
<H4>New Script</H4><PRE>    use CGI qw(:cgi-lib);
    ReadParse();
    print "The price of your purchase is $in{price}.\n";
</PRE>Like cgi-lib's ReadParse, pass a variable <EM>glob</EM> in order to use a 
different variable than the default "%in": <PRE>   ReadParse(*Q);
   @partners = split("\0",$Q{'golf_partners'});
</PRE>
<P>The associative array created by CGI::ReadParse() contains a special key 
'CGI', which returns the CGI query object itself: <PRE>    ReadParse();
    $q = $in{CGI};
    print $q-&gt;textfield(-name=&gt;'wow',
                        -value=&gt;'does this really work?');
</PRE>
<P>This allows you to add the more interesting features of CGI.pm to your old 
scripts without rewriting them completely. As an added benefit, the 
<STRONG>%in</STRONG> variable is actually <CODE>tie()</CODE>'d to the CGI 
object. Changing the CGI object using <STRONG>param()</STRONG> will dynamically 
change <STRONG>%in</STRONG>, and vice-versa. 
<P>cgi-lib.pl's <CODE>@in</CODE> and <CODE>$in</CODE> variables are 
<STRONG>not</STRONG> supported. In addition, the extended version of ReadParse() 
that allows you to spool uploaded files to disk is not available. You are 
strongly encouraged to use CGI.pm's file upload interface instead. 
<P>See <A 
href="http://stein.cshl.org/WWW/software/CGI/cgi-lib_porting.html">cgi-lib_porting.html</A> 
for more details on porting cgi-lib.pl scripts to CGI.pm. 
<HR>

<H2><A name=upload_caveats>Using the File Upload Feature </A></H2>The file 
upload feature doesn't work with every combination of browser and server. The 
various versions of Netscape and Internet Explorer on the Macintosh, Unix and 
Windows platforms don't all seem to implement file uploading in exactly the same 
way. I've tried to make CGI.pm work with all versions on all platforms, but I 
keep getting reports from people of instances that break the file upload 
feature. 
<P>Known problems include: 
<OL>
  <LI>Large file uploads may fail when using SSL version 2.0. This affects the 
  Netscape servers and possibly others that use the SSL library. I have received 
  reports that WebSite Pro suffers from this problem. This is a documented bug 
  in the Netscape implementation of SSL and not a problem with CGI.pm. 
  <LI>If you try to upload a <STRONG>directory</STRONG> path with Unix Netscape, 
  the browser will hang until you hit the "stop" button. I haven't tried to 
  figure this one out since I think it's dumb of Netscape to allow this to 
  happen at all. 
  <LI>If you create the CGI object in one package (e.g. "main") and then obtain 
  the filehandle in a different package (e.g. "foo"), the filehandle will be 
  accessible through "main" but not "foo". In order to use the filehandle, try 
  the following contortion: 
  <BLOCKQUOTE><PRE>      $file = $query-&gt;param('file to upload');
      $file = "main::$file";
          ...
      </PRE></BLOCKQUOTE>I haven't found a way to determine the correct caller 
  in this situation. I might add a readFile() method to CGI if this problem 
  bothers enough people. </LI></OL>The main technical challenge of handling file 
uploads is that it potentially involves sending more data to the CGI script than 
the script can hold in main memory. For this reason CGI.pm creates temporary 
files in either the <CODE>/usr/tmp</CODE> or the <CODE>/tmp</CODE> directory. 
These temporary files have names like <CODE>CGItemp125421</CODE>, and should be 
deleted automatically. 
<P>
<H3>Frequent Problems</H3>
<H4>When you run a script from the command line, it says "offline mode: enter 
name=value pairs on standard input". What do I do now?</H4>This is a prompt to 
enter some CGI parameters for the purposes of debugging. You can now type in 
some parameters like this: <PRE>    first_name=Fred
    last_name=Flintstone
    city=Bedrock
</PRE>End the list by typing a control-D (or control-Z on DOS/Windows systems). 
<P>If you want to run a CGI script from a script or batch file, and don't want 
this behavior, just pass it an empty parameter list like this: <PRE>     my_script.pl ''
</PRE>This will work too on Unix systems: <PRE>     my_script.pl &lt;/dev/null
</PRE>Another option is to use the "-no_debug" pragma when you "use" CGI.pm. 
This will suppress command-line debugging completely: <PRE>use CGI qw/:standard -no_debug/;
</PRE>
<H4>CGI.pm breaks when you use "use integer"</H4>
<P>Due to problems that integer.pm has with unary negation, calls to CGI.pm that 
use the -arg=&gt;value format will break if you load the integer.pm module. This 
is fixed in Perl 5.005_61 and up. 
<P>A workaround is to put all arguments in quotes: '-arg'=&gt;'value' 
<H4>You can't retrieve the name of the uploaded file using the param() 
method</H4>Most likely the remote user isn't using version 2.0 (or higher) of 
Netscape. Alternatively she just isn't filling in the form completely. 
<H4>When you accidentally try to upload a directory name, the browser 
hangs</H4>This seems to be a Netscape browser problem. It starts to upload junk 
to the script, then hangs. You can abort by hitting the "stop" button. 
<H4>You can read the name of the uploaded file, but can't retrieve the 
data</H4>First check that you've told CGI.pm to use the new <A 
href="http://stein.cshl.org/WWW/software/CGI/#multipart">multipart/form-data</A> 
scheme. If it still isn't working, there may be a problem with the temporary 
files that CGI.pm needs to create in order to read in the (potentially very 
large) uploaded files. Internally, CGI.pm tries to create temporary files with 
names similar to <CODE>CGITemp123456</CODE> in a temporary directory. To find a 
suitable directory it first looks for <CODE>/usr/tmp</CODE> and then for 
<CODE>/tmp</CODE>. If it can't find either of these directories, it tries for 
the current directory, which is usually the same directory that the script 
resides in. 
<P>If you're on a non-Unix system you may need to modify CGI.pm to point at a 
suitable temporary directory. This directory must be writable by the user ID 
under which the server runs (usually "nobody") and must have sufficient capacity 
to handle large file uploads. Open up CGI.pm, and find the line: <PRE>      package TempFile;
      foreach ('/usr/tmp','/tmp') {
         do {$TMPDIRECTORY = $_; last} if -d $_ &amp;&amp; -w _;
      }
</PRE>Modify the foreach() line to contain a series of one or more directories 
to store temporary files in. 
<P>Alternatively, you can just skip the search entirely and force CGI.pm to 
store its temporary files in some logical location. Do this at the top of your 
script with a line like this one: $TempFile::TMPDIRECTORY='/WWW_ROOT'; 
<H4>On Windows Systems, the temporary file is never deleted, but hangs around in 
<CODE>\temp</CODE>, taking up space.</H4>Be sure to close the filehandle before 
your program exits. In fact, close the file as soon as you're finished with it, 
because the file will end up hanging around if the script later crashes. 
<P>Unix users don't have this problem, because well designed operating systems 
make it possible to delete a file without closing it. 
<H4>When you press the "back" button, the same page is loaded, not the previous 
one.</H4>Netscape 2.0's history list gets confused when processing multipart 
forms. If the script generates different pages for the form and the results, 
hitting the "back" button doesn't always return you to the previous page; 
instead Netscape reloads the current page. This happens even if you don't use an 
upload file field in your form. 
<P>A workaround for this is to use additional path information to trick Netscape 
into thinking that the form and the response have different URLs. I recommend 
giving each form a sequence number and bumping the sequence up by one each time 
the form is accessed: <PRE>   my($s) = $query-&gt;path_info=~/(\d+)/; # get sequence
   $s++;                                #bump it up
   # Trick Netscape into thinking it's loading a new script:
   print $q-&gt;start_multipart_form(-action=&gt;$q-&gt;script_name . "/$s");
</PRE>
<H4>You can't find the temporary file that CGI.pm creates</H4>You're encouraged 
to copy the data into your own file by reading from the file handle that CGI.pm 
provides you with. In the future there may be no temporary file at all, just a 
pipe. However, for now, if you really want to get at the temp file, you can 
retrieve its path using the <A 
href="http://stein.cshl.org/WWW/software/CGI/#tmpfilename">tmpFileName()</A> 
method. Be sure to move the temporary file elsewhere in the file system if you 
don't want it to be automatically deleted when CGI.pm exits. 
<HR>

<H2><A name=push>Server Push</A></H2>
<P>CGI.pm provides four simple functions for producing multipart documents of 
the type needed to implement server push. To import these into your namespace, 
you must import the ":push" set. You are also advised to put the script into NPH 
mode and to set $| to 1 to avoid buffering problems. </P>
<P>Here is a simple script that demonstrates server push:</P>
<BLOCKQUOTE><PRE>#!/usr/local/bin/perl
use CGI qw/:push -nph/;
$| = 1;
print multipart_init(-boundary=&gt;'----------------here we go!');
foreach (0 .. 4) {
   print multipart_start(-type=&gt;'text/plain'),
         "The current time is ",scalar(localtime),"\n";
   if ($_ &lt; 4) {
      print multipart_end;
   } else {
      print multipart_final;
   }
   sleep 1;
}
</PRE></BLOCKQUOTE>
<P>This script initializes server push by calling <CITE>multipart_init()</CITE>. 
It then enters a loop in which it begins a new multipart section by calling 
<CITE>multipart_start()</CITE>, prints the current local time, and ends a 
multipart section with <CITE>multipart_end()</CITE>. It then sleeps a second, 
and begins again. On the final iteration, it ends the multipart section with 
<CITE>multipart_final()</CITE> rather than with <CITE>multipart_end()</CITE>. 
</P>
<DL>
  <DT>multipart_init() 
  <DD>
  <BLOCKQUOTE><PRE>multipart_init(-boundary=&gt;$boundary);
      </PRE></BLOCKQUOTE>Initialize the multipart system. The -boundary 
  argument specifies what MIME boundary string to use to separate parts of the 
  document. If not provided, CGI.pm chooses a reasonable boundary for you. 
  <P></P>
  <DT>multipart_start() 
  <DD>
  <BLOCKQUOTE><PRE>multipart_start(-type=&gt;$type)
      </PRE></BLOCKQUOTE>Start a new part of the multipart document using the 
  specified MIME type. If not specified, text/html is assumed. 
  <P></P>
  <DT>multipart_end() 
  <DD>
  <BLOCKQUOTE><PRE>  multipart_end()
      </PRE></BLOCKQUOTE>End a part. You must remember to call multipart_end() 
  once for each multipart_start(), except at the end of the last part of the 
  multipart document when multipart_final() should be called instead of 
  multipart_end(). 
  <P></P>
  <DT>multipart_final() 
  <DD>
  <BLOCKQUOTE><PRE>  multipart_final()
      </PRE></BLOCKQUOTE>End all parts. You should call multipart_final() 
  rather than multipart_end() at the end of the last part of the multipart 
  document. </DD></DL>Users interested in server push applications should also 
have a look at the CGI::Push module. 
<P>Only Netscape Navigator supports server push. Internet Explorer browsers do 
not.</P>
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of 
contents</A> 
<HR>

<H2><A name=dos>Avoiding Denial of Service Attacks</A></H2>A potential problem 
with CGI.pm is that, by default, it attempts to process form POSTings no matter 
how large they are. A wily hacker could attack your site by sending a CGI script 
a huge POST of many megabytes. CGI.pm will attempt to read the entire POST into 
a variable, growing hugely in size until it runs out of memory. While the script 
attempts to allocate the memory the system may slow down dramatically. This is a 
form of denial of service attack. 
<P>Another possible attack is for the remote user to force CGI.pm to accept a 
huge file upload. CGI.pm will accept the upload and store it in a temporary 
directory even if your script doesn't expect to receive an uploaded file. CGI.pm 
will delete the file automatically when it terminates, but in the meantime the 
remote user may have filled up the server's disk space, causing problems for 
other programs. 
<P>The best way to avoid denial of service attacks is to limit the amount of 
memory, CPU time and disk space that CGI scripts can use. Some Web servers come 
with built-in facilities to accomplish this. In other cases, you can use the 
shell <EM>limit</EM> or <EM>ulimit</EM> commands to put ceilings on CGI resource 
usage. 
<P>CGI.pm also has some simple built-in protections against denial of service 
attacks, but you must activate them before you can use them. These take the form 
of two global variables in the CGI name space: 
<DL>
  <DT><STRONG><TT>$CGI::POST_MAX</TT></STRONG> 
  <DD>If set to a non-negative integer, this variable puts a ceiling on the size 
  of POSTings, in bytes. If CGI.pm detects a POST that is greater than the 
  ceiling, it will immediately exit with an error message. This value will 
  affect both ordinary POSTs and multipart POSTs, meaning that it limits the 
  maximum size of file uploads as well. You should set this to a reasonably high 
  value, such as 1 megabyte. 
  <P></P>
  <DT><STRONG><TT>$CGI::DISABLE_UPLOADS</TT></STRONG> 
  <DD>If set to a non-zero value, this will disable file uploads completely. 
  Other fill-out form values will work as usual. </DD></DL>You can use these 
variables in either of two ways. 
<OL>
  <LI>On a script-by-script basis. Set the variable at the top of the script, 
  right after the "use" statement: <PRE>      use CGI qw/:standard/;
      use CGI::Carp 'fatalsToBrowser';
      $CGI::POST_MAX=1024 * 100;  # max 100K posts
      $CGI::DISABLE_UPLOADS = 1;  # no uploads
      </PRE>
  <P></P>
  <LI>Globally for all scripts. Open up CGI.pm, find the definitions for 
  <TT>$POST_MAX</TT> and <TT>$DISABLE_UPLOADS</TT>, and set them to the desired 
  values. You'll find them towards the top of the file in a subroutine named 
  <TT>initialize_globals</TT>. </LI></OL>Since an attempt to send a POST larger 
than <TT>$POST_MAX</TT> bytes will cause a fatal error, you might want to use 
CGI::Carp to echo the fatal error message to the browser window as shown in the 
example above. Otherwise the remote user will see only a generic "Internal 
Server" error message. See the manual page for CGI::Carp for more details. 
<P>An attempt to send a POST larger than $POST_MAX bytes will cause 
<B>param()</B> to return an empty CGI parameter list. You can test for this 
event by checking <B>cgi_error()</B>, either after you create the CGI object or, 
if you are using the function-oriented interface, call <B>param()</B> for the 
first time. If the POST was intercepted, then cgi_error() will return the 
message "413 POST too large". 
<P>This error message is actually defined by the HTTP protocol, and is designed 
to be returned to the browser as the CGI script's status code. For example: <PRE>$uploaded_file = param('upload');
   if (!$uploaded_file &amp;&amp; cgi_error()) {
      print header(-status=&gt;cgi_error());
      exit 0;
   }
</PRE>
<P>Some browsers may not know what to do with this status code. It may be better 
just to create an HTML page that warns the user of the problem. <A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of contents</A> 
<HR>

<H2><A name=non_unix>Using CGI.pm on non-Unix Platforms</A></H2>I don't have 
access to all the combinations of hardware and software that I really need to 
make sure that CGI.pm works consistently for all Web servers, so I rely heavily 
on helpful reports from users like yourself. 
<P>There are a number of differences in file name and text processing 
conventions on different platforms. By default, CGI.pm is set up to work 
properly on a Unix (or Linux) system. During load, it will attempt to guess the 
correct operating system using the Config module. Currently it guesses 
correctly; however if the operating system names change it may not work right. 
The main symptom will be that file upload does not work correctly. If this 
happens, find the place at the top of the script where the OS is defined, and 
uncomment the correct definition: <PRE>   # CHANGE THIS VARIABLE FOR YOUR OPERATING SYSTEM
   # $OS = 'UNIX';
   # $OS = 'MACINTOSH';
   # $OS = 'WINDOWS';
   # $OS = 'VMS';
</PRE>Other notes follow: 
<H3><A name=windows>Windows NT</A></H3>CGI.pm works well with WebSite, the 
EMWACS server, Purveyor and the Microsoft IIS server. CGI.pm must be put in the 
perl5 library directory, and all CGI scripts that use it should be placed in 
cgi-bin directory. You also need to associate the <CODE>.pl</CODE> suffix with 
perl5 using the NT file manager (Website, Purveyor), or install the correct 
script mapping registry keys for IIS. Perl for Windows is available from the 
ActiveState company, which can be found at: 
<BLOCKQUOTE><A 
  href="http://www.activestate.com/">http://www.activestate.com/</A> </BLOCKQUOTE>
<P>WebSite uses a slightly different cgi-bin directory structure than the 
standard. For this server, place the scripts in the <CODE>cgi-shl</CODE> 
directory. CGI.pm appears to work correctly in both the Windows95 and WindowsNT 
versions of WebSite. 
<P>Old Netscape Communications Server technical notes recommended placing 
<CODE>perl.exe</CODE> in cgi-bin. This a very bad idea because it opens up a 
gaping security hole. Put a C <CODE>.exe</CODE> wrapper around the perl script 
until such time as Netscape recognizes NT file manager associations, or provides 
a Perl-compatible DLL library for its servers. 
<P>If you find that binary files get slightly larger when uploaded but that text 
files remain the same, then binary made is not correctly activated. Be sure to 
set the $OS variable to 'NT' or 'WINDOWS'. If you continue to have problems, 
make sure you're calling <STRONG>binmode()</STRONG> on the filehandle that you 
use to write the uploaded file to disk. 
<H3>VMS</H3>I don't have access to a VMS machine, and I'm not sure whether file 
upload works correctly. Other features are known to work. 
<H3>Macintosh</H3>Most CGI.pm features work with MacPerl version 5.0.6r1 or 
higher under the WebStar and MacHTTP servers. In order to install a Perl program 
to use with the Web, you'll need Matthias Nuuracher's PCGI extension, available 
at: 
<BLOCKQUOTE><PRE><A href="ftp://err.ethz.ch/pub/neeri/MacPerl/">ftp://err.ethz.ch/pub/neeri/MacPerl/</A>
</PRE></BLOCKQUOTE>Known incompatibilities between CGI.pm and MacPerl include: 
<OL>
  <LI>The perl compiler will object to the use of -values in named parameters. 
  Put single quotes around this parameter ('-values') or use the singular form 
  ('-value') instead. 
  <LI>File upload isn't working in my hands (Perl goes into an endless loop). 
  Other people have gotten it to work. </LI></OL>
<HR>

<H2><A name=future>The Relation of this Library to the CGI Modules</A></H2>This 
library is maintained in parallel with the full featured CGI, URL, and HTML 
modules. I use this library to test out new ideas before incorporating them into 
the CGI hierarchy. I am continuing to maintain and improve this library in order 
to satisfy people who are looking for an easy-to-use introduction to the world 
of CGI scripting. 
<P>The CGI::* modules are being reworked to be interoperable with the excellent 
LWP modules. Stay tuned. 
<P>The current version of CGI.pm can be found at: <PRE>  <A href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW">http://www.genome.wi.mit.edu/ftp/pub/software/WWW</A>
</PRE>
<P>You are encouraged to look at these other Web-related modules: 
<DL>
  <DT><A 
  href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW/CGIperl/">CGI::Base,CGI::Form,CGI::MiniSrv,CGI::Request 
  and CGI::URI::URL</A> 
  <DD>Modules for parsing script input, manipulating URLs, creating forms and 
  even launching a miniature Web server. 
  <DT><A href="http://www.ics.uci.edu/pub/websoft/libwww-perl/">libwww-perl</A> 
  <DD>Modules for fetching Web resources from within Perl, writing Web robots, 
  and much more. </DD></DL>You might also be interested in two packages for 
creating graphics on the fly: 
<DL>
  <DT><A 
  href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW/GD.html">GD.html</A> 
  <DD>A module for creating GIF images on the fly, using Tom Boutell's <A 
  href="http://www.boutell.com/gd/">gd</A> graphics library. 
  <DT><A 
  href="http://www.genome.wi.mit.edu/ftp/pub/software/utilities/">qd.pl</A> 
  <DD>A library for creating Macintosh PICT files on the fly (which can be 
  converted to GIF or JPEG using NetPBM). </DD></DL>
<P>For a collection of CGI scripts of various levels of complexity, see the 
companion pages for my book <A href="http://www.genome.wi.mit.edu/WWW/">How to 
Set Up and Maintain a World Wide Web Site</A> 
<HR>

<H2><A name=distribution>Distribution Information:</A></H2>This code is 
copyright 1995-1998 by Lincoln Stein. It may be used and modified freely, but I 
do request that this copyright notice remain attached to the file. You may 
modify this module as you wish, but if you redistribute a modified version, 
please attach a note listing the modifications you have made. 
<HR>

<H2><A name=book>The CGI.pm Book</A></H2><CITE>The Official Guide to 
CGI.pm</CITE>, by Lincoln Stein, is packed with tips and techniques for using 
the module, along with information about the module's internals that can't be 
found anywhere else. It is available on bookshelves now, or can be ordered from 
<A href="http://www.amazon.com/">amazon.com</A>. Also check the book's companion 
Web site at: 
<BLOCKQUOTE><A 
  href="http://www.wiley.com/compbooks/stein/">http://www.wiley.com/compbooks/stein/</A> 
</BLOCKQUOTE>
<HR>

<H2><A name=y2000>CGI.pm and the Year 2000 Problem</A></H2>Versions of CGI.pm 
prior to 2.36 suffered a year 2000 problem in the handling of cookies. Cookie 
expiration dates were expressed using two digits as dictated by the then-current 
Netscape cookie protocol. The cookie protocol has since been cleaned up. My 
belief is that versions of CGI.pm 2.36 and higher are year 2000 compliant. 
<HR>

<H2><A name=mailingList>The CGI-perl mailing list</A></H2>The CGI Perl mailing 
list is defunct and is unlikely to be resurrected. Please address your questions 
to <A 
href="news:comp.infosystems.www.authoring.cgi">comp.infosystems.www.authoring.cgi</A> 
if they relate to the CGI protocol or the usage of CGI.pm <I>per gse</I>, or to 
<A href="news:comp.lang.perl.misc">comp.lang.perl.misc</A> for Perl 
<STRONG>language</STRONG> issues. Please read this documentation thoroughly, 
read the FAQs for these newsgroups and scan through previous messages before you 
make a posting. Respondents are not always friendly to people who neglect to do 
so! 
<H2><A name=bugs>Bug Reports</A></H2>Address bug reports and comments to:<BR><A 
href="mailto:lstein@cshl.org">lstein@cshl.org</A>. When sending bug reports, 
please provide the following information: 
<UL>
  <LI>the version of CGI.pm (<CODE>perl -MCGI -e 'print $CGI::VERSION'</CODE>) 
  <LI>the version of Perl (<CODE>perl -v</CODE>) 
  <LI>the name and version of your Web server 
  <LI>the name and version of the operating system you are using 
  <LI>if applicable, the name and version of the browser you are using 
  <LI>a short test script that reproduces the problem (30 lines or less) 
</LI></UL>It is very important that I receive this information in order to help 
you. 
<P><A href="http://stein.cshl.org/WWW/software/CGI/#contents">Up to table of 
contents</A> 
<HR>

<H2><A name=new>Revision History</A></H2>
<H3>Version 2.81</H3>
<OL>
  <LI>Removed extraneous slash from end of stylesheet tags generated by 
  start_html in non-XHTML mode. 
  <LI>Changed behavior of CGI::Carp with respect to eval{} contexts so that 
  output behaves properly in mod_perl environments. 
  <LI>Fixed default DTD so that it validates with W3C validator. </LI></OL>
<H3>Version 2.80</H3>
<OL>
  <LI>Fixed broken messages in CGI::Carp. 
  <LI>Changed checked="1" to checked="checked" for real XHTML compatibility. 
  <LI>Resurrected REQUEST_URI code so that url() works correctly with 
  multiviews. </LI></OL>
<H3>Version 2.79</H3>
<OL>
  <LI>Changes to CGI::Carp to avoid "subroutine redefined" error messages. 
  <LI>Default DTD is now XHTML 1.0 Transitional 
  <LI>Patches to support all HTML4 tags. </LI></OL>
<H3>Version 2.78</H3>
<OL>
  <LI>Added ability to change encoding in &lt;?xml&gt; assertion. 
  <LI>Fixed the old escapeHTML('CGI') ne "CGI" bug 
  <LI>In accordance with XHTML requirements, there are no longer any minimized 
  attributes, such as "checked". 
  <LI>Patched bug which caused file uploads of exactly 4096 bytes to be 
  truncated to 4094 (thanks to Kevin Mahony) 
  <LI>New tests and fixes to CGI::Pretty (thanks to Michael Schwern). </LI></OL>
<H3>Version 2.77</H3>
<OL>
  <LI>No new features, but released in order to fix an apparent CPAN bug. 
</LI></OL>
<H3>Version 2.76</H3>
<OL>
  <LI>New esc.t regression test for EBCDIC translations courtesy Peter Prymmer. 
  <LI>Patches from James Jurach to make compatible with FCGI-ProcManager 
  <LI>Additional fields passed to header() (like -Content_disposition) now honor 
  initial capitalization. 
  <LI>Patch from Andrew McNaughton to handle utf-8 escapes (%uXXXX codes) in 
  URLs. </LI></OL>
<H3>Version 2.752</H3>
<OL>
  <LI>Syntax error in the autoloaded Fh::new() subroutine. 
  <LI>Better error reporting in autoloaded functions. </LI></OL>
<H3>Version 2.751</H3>
<OL>
  <LI>Tiny tweak to filename regular expression function on line 3355. </LI></OL>
<H3>Version 2.75</H3>
<OL>
  <LI>Fixed bug in server push boundary strings (CGI.pm and CGI::Push). 
  <LI>Fixed bug that occurs when uploading files with funny characters in the 
  name 
  <LI>Fixed non-XHTML-compliant attributes produced by textfield() 
  <LI>Added EPOC support, courtesy Olaf Flebbe 
  <LI>Fixed minor XHTML bugs. 
  <LI>Made escape() and unescape() symmetric with respect to EBCDIC, courtesy 
  Roca, Ignasi &lt;ignasi.roca@fujitsu.siemens.es&gt; 
  <LI>Removed uninitialized variable warning from CGI::Cookie, provided by 
  Atipat Rojnuckarin &lt;rojnuca@yahoo.com&gt; 
  <LI>Fixed bug in CGI::Pretty that causes it to print partial end tags when the 
  $INDENT global is changed. 
  <LI>Single quotes are changed to character entity ' for compatibility with 
  URLs. </LI></OL>
<H3>Version 2.74</H3>
<P>September 13, 2000 
<OL>
  <LI>Quashed one-character bug that caused CGI.pm to fail on file uploads. 
</LI></OL>
<H3>Version 2.73</H3>
<P>September 12, 2000 
<OL>
  <LI>Added -base to the list of arguments accepted by url(). 
  <LI>Fixes to XHTML support. 
  <LI>POST parameters no longer show up in the Location box. </LI></OL>
<H3>Version 2.72</H3>
<P>August 19, 2000 
<OL>
  <LI>Fixed the defaults button so that it works again 
  <LI>Charset is now correctly saved and restored when saving to files 
  <LI>url() now works correctly when given scripts with %20 and other escapes in 
  the additional path info. This undoes a patch introduced in version 2.47 that 
  I no longer understand the rationale for. </LI></OL>
<H3>Version 2.71</H3>
<P>August 13, 2000 
<OL>
  <LI>Newlines in the value attributes of hidden fields and other form elements 
  are now escaped when using ISO-Latin. 
  <LI>Inline script and style sections are now protected as CDATA sections when 
  XHTML mode is on (the default). </LI></OL>
<H3>Version 2.70</H3>
<P>August 4, 2000 
<OL>
  <LI>Fixed bug in scrolling_list() which omitted a space in front of the 
  "multiple" attribute. 
  <LI>Squashed the "useless use of string in void context" message from 
  redirects. </LI></OL>
<H3>Version 2.69</H3>
<OL>
  <LI>startform() now creates default ACTION for POSTs as well as GETs. This may 
  break some browsers, but it no longer violates the HTML spec. 
  <LI>CGI.pm now emits XHTML by default. Disable with -no_xhtml. 
  <LI>We no longer interpret &amp;#ddd sequences in non-latin character sets. 
  </LI></OL>
<H3>Version 2.68</H3>
<OL>
  <LI>No longer attempts to escape characters when dealing with non ISO-8861 
  character sets. 
  <LI>checkbox() function now defaults to using -value as its label, rather than 
  -name. The current behavior is what has been documented from the beginning. 
  <LI>-style accepts array reference to incorporate multiple stylesheets into 
  document. </LI></OL>
<OL>
  <LI>Fixed two bugs that caused the -compile pragma to fail with a syntax 
  error. </LI></OL>
<H3>Version 2.67</H3>
<OL>
  <LI>Added XHTML support (incomplete; tags need to be lowercased). 
  <LI>Fixed CGI/Carp when running under mod_perl. Probably broke in other 
  contexts. 
  <LI>Fixed problems when passing multiple cookies. 
  <LI>Suppress warnings from _tableize() that were appearing when using -w 
  switch with radio_group() and checkbox_group(). 
  <LI>Support for the header() -attachment argument, which can give pages a 
  default file name when saving to disk. </LI></OL>
<H3>Version 2.66</H3>
<OL>
  <LI>2.65 changes in make_attributes() broke HTTP header functions (including 
  redirect), so made it context sensitive. </LI></OL>
<H3>Version 2.65</H3>
<OL>
  <LI>Fixed regression tests to skip tests that require implicit fork on 
  machines without fork(). 
  <LI>Changed make_attributes() to automatically escape any HTML reserved 
  characters. 
  <LI>Minor documentation fix in javascript example. </LI></OL>
<H3>Version 2.64</H3>
<OL>
  <LI>Changes introduced in 2.63 broke param() when retrieving parameter lists 
  containing only a single argument. This is now fixed. 
  <LI>self_url() now defaults to returning parameters delimited with semicolon. 
  Use the pragma -oldstyle_urls to get the old "&amp;" delimiter. </LI></OL>
<H3>Version 2.63</H3>
<OL>
  <LI>Fixed CGI::Push to pull out parameters correctly. 
  <LI>Fixed redirect() so that it works with default character set 
  <LI>Changed param() so as to returned empty string '' when referring to 
  variables passed in query strings like 'name1=&amp;name2' </LI></OL>
<H3>Version 2.62</H3>
<OL>
  <LI>Fixed broken ReadParse() function, and added regression tests 
  <LI>Fixed broken CGI::Pretty, and added regression tests </LI></OL>
<H3>Version 2.61</H3>
<OL>
  <LI>Moved more functions from CGI.pm proper into CGI/Util.pm. CGI/Cookie 
  should now be standalone. 
  <LI>Disabled per-user temporary directories, which were causing grief. 
</LI></OL>
<H3>Version 2.60</H3>
<OL>
  <LI>Fixed junk appearing in autogenerated HTML functions when using 
  object-oriented mode. </LI></OL>
<H3>Version 2.59</H3>
<OL>
  <LI>autoescape functionality breaks too much existing code, removed it. 
  <LI>use escapeHTML() manually </LI></OL>
<H3>Version 2.58</H3>This is the release version of 2.57. 
<H3>Version 2.57</H3>
<OL>
  <LI>Added -debug pragma and turned off auto reading of STDIN. 
  <LI>Default DTD updated to HTML 4.01 transitional. 
  <LI>Added charset() method and the -charset argument to header(). 
  <LI>Fixed behavior of escapeHTML() to respect charset() and to escape nasty 
  Windows characters (thanks to Tom Christiansen). 
  <LI>Handle REDIRECT_QUERY_STRING correctly. 
  <LI>Removed use_named_parameters() because of dependency problems and general 
  lameness. 
  <LI>Fixed problems with bad HREF links generated by url(-relative=&gt;1) when 
  the url is like /people/. 
  <LI>Silenced a warning on upload (patch provided by Jonas Liljegren) 
  <LI>Fixed race condition in CGI::Carp when errors occur during parsing (patch 
  provided by Maurice Aubrey). 
  <LI>Fixed failure of url(-path_info=&gt;1) when path contains % signs. 
  <LI>Fixed warning from CGI::Cookie when receiving foreign cookies that don't 
  use name=value format. 
  <LI>Fixed incompatibilities with file uploading on VMS systems. </LI></OL>
<H3>Version 2.56</H3>
<OL>
  <LI>Fixed bugs in file upload introduced in version 2.55 
  <LI>Fixed long-standing bug that prevented two files with identical names from 
  being uploaded. </LI></OL>
<H3>Version 2.55</H3>
<OL>
  <LI>Fixed cookie regression test so as not to produce an error. 
  <LI>Fixed path_info() and self_url() to work correctly together when 
  path_info() modified. 
  <LI>Removed manify warnings from CGI::{Switch,Apache}. </LI></OL>
<H3>Version 2.54</H3>
<OL>
  <LI>This will be the last release of the monolithic CGI.pm module. Later 
  versions will be modularized and optimized. 
  <LI>DOMAIN tag no longer added to cookies by default. This will break some 
  versions of Internet Explorer, but will avoid breaking networks which use host 
  tables without fully qualified domain names. For compatibility, please always 
  add the -domain tag when creating cookies. 
  <LI>Fixed escape() method so that +'s are treated correctly. 
  <LI>Updated CGI::Pretty module. </LI></OL>
<H3>Version 2.53</H3>
<OL>
  <LI>Forgot to upgrade regression tests before releasing 2.52. <B>NOTHING ELSE 
  HAS CHANGED IN LIBRARY</B> </LI></OL>
<H3>Version 2.52</H3>
<OL>
  <LI>Spurious newline in checkbox() routine removed. (courtesy John Essen) 
  <LI>TEXTAREA linebreaks now respected in dump() routine. (courtesy John Essen) 

  <LI>Patches for DOS ports (courtesy Robert Davies) 
  <LI>Patches for VMS 
  <LI>More fixes for cookie problems 
  <LI>Fix CGI::Carp so that it doesn't affect eval{} blocks (courtesy Byron 
  Brummer) </LI></OL>
<H3>Version 2.51</H3>
<OL>
  <LI>Fixed problems with cookies not being remembered when sent to IE 5.0 (and 
  Netscape 5.0 too?) 
  <LI>Numerous HTML compliance problems in cgi_docs.html; fixed thanks to 
  Michael Leahy </LI></OL>
<H3>Version 2.50</H3>
<OL>
  <LI>Added a new Vars() method to retrieve all parameters as a tied hash. 
  <LI>Untainted tainted tempfile name so that script doesn't fail on terminal 
  unlink. 
  <LI>Made picking of upload tempfile name more intelligent so that doesn't fail 
  in case of name collision. 
  <LI>Fixed handling of expire times when passed an absolute timestamp. 
  <LI>Changed dump() to Dump() to avoid name clashes. </LI></OL>
<H3>Version 2.49</H3>
<OL>
  <LI>Fixes for FastCGI (globals not getting reset) 
  <LI>Fixed url() to correctly handle query string and path under MOD_PERL 
</LI></OL>
<H3>Version 2.48</H3>
<OL>
  <LI>Reverted detection of MOD_PERL to avoid breaking PerlEX. </LI></OL>
<H3>Version 2.47</H3>
<OL>
  <LI>Patch to fix file upload bug appearing in IE 3.01 for Macintosh/PowerPC. 
  <LI>Replaced use of $ENV{SCRIPT_NAME} with $ENV{REQUEST_URI} when running 
  under Apache, to fix self-referencing URIs. 
  <LI>Fixed bug in escapeHTML() which caused certain constructs, such as 
  CGI-&gt;image_button(), to fail. 
  <LI>Fixed bug which caused strong('CGI') to fail. Be careful to use 
  CGI::strong('CGI') and not CGI-&gt;strong('CGI'). The latter will produce 
  confusing results. 
  <LI>Added <B>upload()</B> function, as a preferred replacement for the 
  "filehandle as string" feature. 
  <LI>Added <B>cgi_error()</B> function. 
  <LI>Rewrote file upload handling to return undef rather than dieing when an 
  error is encountered. Be sure to call <B>cgi_error()</B> to find out what went 
  wrong. </LI></OL>
<H3>Version 2.46</H3>
<OL>
  <LI>Fix for failure of the "include" tests under mod_perl 
  <LI>Added end_multipart_form to prevent failures during qw(-compile :all) 
</LI></OL>
<H3>Version 2.45</H3>
<OL>
  <LI>Multiple small documentation fixes 
  <LI><CITE>CGI::Pretty</CITE> didn't get into 2.44. Fixed now. </LI></OL>
<H3>Version 2.44</H3>
<OL>
  <LI>Fixed file descriptor leak in upload function. 
  <LI>Fixed bug in header() that prevented fields from containing double quotes. 

  <LI>Added Brian Paulsen's <CITE>CGI::Pretty</CITE> package for pretty-printing 
  output HTML. 
  <LI>Removed CGI::Apache and CGI::Switch from the distribution. 
  <LI>Generated start_* shortcuts so that start_table(), end_table(), 
  start_ol(), end_ol(), and so forth now work (see the docs on how to enable 
  this feature). 
  <LI>Changed accept() to Accept(), sub() to Sub(). There's still a conflict 
  with reset(), but this will break too many existing scripts! </LI></OL>
<H3>Version 2.43</H3>
<OL>
  <LI>Fixed problem with "use strict" and file uploads (thanks to Peter Haworth) 

  <LI>Fixed problem with not MSIE 3.01 for the power_mac not doing file uploads 
  right. 
  <LI>Fixed problem with file upload on IIS 4.0 when authorization in use. 
  <LI>-content_type and '-content-type' can now be provided to header() as 
  synonyms for -type. 
  <LI>CGI::Carp now escapes the ampersand BEFORE escaping the &gt; and &lt; 
  signs. 
  <LI>Fixed "not an array reference" error when passing a hash reference to 
  radio_group(). 
  <LI>Fixed non-removal of uploaded TMP files on NT platforms which occurs when 
  server runs on non-C drive (thanks to Steve Kilbane for finding this one). 
  </LI></OL>
<H3>Version 2.42</H3>
<OL>
  <LI>Too many screams of anguish at changed behavior of url(). Is now back to 
  its old behavior by default, with options to generate all the variants. 
  <LI>Added regression tests. "make test" now works. 
  <LI>Documentation fixes. 
  <LI>Fixes for Macintosh uploads, but uploads STILL do not work pending changes 
  to MacPerl. </LI></OL>
<H3>Version 2.41</H3>
<OL>
  <LI>url() method now includes the path info. Use script_name() to get it 
  without path info(). 
  <LI>Changed handling of empty attributes in HTML tag generation. Be warned! 
  Use <TT>table({-border=&gt;undef})</TT> rather than 
  <TT>table({-border=&gt;''})</TT>. 
  <LI>Changes to allow uploaded filenames to be compared to other strings with 
  "eq", "cmp" and "ne". 
  <LI>Changes to allow CGI.pm to coexist more peacefully with ActiveState 
  PerlEX. 
  <LI>Changes to prevent exported variables from clashing when importing ":all" 
  set in combination with cookies. </LI></OL>
<H3>Version 2.40</H3>
<OL>
  <LI>CGI::Carp patched to work better with mod_perl (thanks to Chris Dean). 
  <LI>Uploads of files whose names begin with numbers or the Windows 
  \\UNC\shared\file nomenclature should no longer fail. 
  <LI>The &lt;STYLE&gt; tag (for cascading style sheets) now generates the 
  required TYPE attribute. 
  <LI>Server push primitives added, thanks to Ed Jordan. 
  <LI>Table and other HTML3 functions are now part of the :standard set. 
  <LI>Small documentation fixes. </LI></OL><EM>TO DO:</EM> 
<OL>
  <LI>Do something about the DTD mess. The module should generate correct DTDs, 
  or at least offer the programmer a way to specify the correct one. 
  <LI>Split CGI.pm into CGI processing and HTML-generating modules. 
  <LI>More robust file upload (?still not working on the Macintosh?). 
  <LI>Bring in all the HTML4 functionality, particular the accessibility 
  features. </LI></OL>
<H3>Version 2.39</H3>
<OL>
  <LI>file uploads failing because of VMS patch; fixed. 
  <LI>-dtd parameter was not being properly processed. </LI></OL>
<H3>Version 2.38</H3>I finally got tired of all the 2.37 betas and released 
2.38. The main difference between this version and the last 2.37 beta (2.37b30) 
are some fixes for VMS. This should allow file upload to work properly on all 
VMS Web servers. 
<H3>Version 2.37, various beta versions</H3>
<OL>
  <LI>Added a CGI::Cookie::parse() method for lucky mod_perl users. 
  <LI>No longer need separate -values and -labels arguments for multi-valued 
  form elements. 
  <LI>Added better interface to raw cookies (fix courtesy Ken Fox, 
  kfox@ford.com) 
  <LI>Added param_fetch() function for direct access to parameter list. 
  <LI>Fix to checkbox() to allow for multi-valued single checkboxes (weird 
  problem). 
  <LI>Added a compile() method for those who want to compile without importing. 
  <LI>Documented the import pragmas a little better. 
  <LI>Added a -compile switch to the use clause for the long-suffering mod_perl 
  and Perl compiler users. 
  <LI>Fixed initialization routines so that FileHandle and type globs work 
  correctly (and hash initialization doesn't fail!). 
  <LI>Better deletion of temporary files on NT systems. 
  <LI>Added documentation on escape(), unescape(), unescapeHTML() and 
  unescapeHTML() subroutines. 
  <LI>Added documentation on creating subclasses. 
  <LI>Fixed problem when calling $self-&gt;SUPER::foo() from inheriting 
  subclasses. 
  <LI>Fixed problem using filehandles from within subroutines. 
  <LI>Fixed inability to use the string "CGI" as a parameter. 
  <LI>Fixed exponentially growing $FILLUNIT bug 
  <LI>Check for undef filehandle in read_from_client() 
  <LI>Now requires the UNIVERSAL.pm module, present in Perl 5.003_7 or higher. 
  <LI>Fixed problem with uppercase-only parameters being ignored. 
  <LI>Fixed vanishing cookie problem. 
  <LI>Fixed warning in initialize_globals() under mod_perl. 
  <LI>File uploads from Macintosh versions of MSIE should now work. 
  <LI>Pragmas now preceded by dashes (-nph) rather than colons (:nph). Old style 
  is supported for backward compatability. 
  <LI>Can now pass arguments to all functions using {} brackets, resolving 
  historical inconsistencies. 
  <LI>Removed autoloader warnings about absent MultipartBuffer::DESTROY. 
  <LI>Fixed non-sticky checkbox() when -name used without -value. 
  <LI>Hack to fix path_info() in IIS 2.0. Doesn't help with IIS 3.0. 
  <LI>Parameter syntax for debugging from command line now more straightforward. 

  <LI>Added $DISABLE_UPLOAD to disable file uploads. 
  <LI>Added $POST_MAX to error out if POSTings exceed some ceiling. 
  <LI>Fixed url_param(), which wasn't working at all. 
  <LI>Fixed variable suicide problem in s///e expressions, where the autoloader 
  was needed during evaluation. 
  <LI>Removed excess spaces between elements of checkbox and radio groups 
  <LI>Can now create "valueless" submit buttons 
  <LI>Can now set path_info as well as read it. 
  <LI>ReadParse() now returns a useful function result. 
  <LI>import_names() now allows you to optionally clear out the namespace before 
  importing (for mod_perl users) 
  <LI>Made it possible to have a popup menu or radio button with a value of "0". 

  <LI>link() changed to Link() to avoid overriding native link function. 
  <LI>Takes advantage of mod_perl's register_cleanup() function to clear 
  globals. 
  <LI>&lt;LAYER&gt; and &lt;ILAYER&gt; added to :html3 functions. 
  <LI>Fixed problems with private tempfiles and NT/IIS systems. 
  <LI>No longer prints the DTD by default (I bet no one will complain). 
  <LI>Allow underscores to replace internal hyphens in parameter names. 
  <LI>CGI::Push supports heterogeneous MIME types and adjustable delays between 
  pages. 
  <LI>url_param() method added for retrieving URL parameters even when a 
  fill-out form is POSTed. 
  <LI>Got rid of warnings when radio_group() is called. 
  <LI>Cookies now moved to their very own module. 
  <LI>Fixed documentation bug in CGI::Fast. 
  <LI>Added a :no_debug pragma to the import list. </LI></OL>
<H3>Version 2.36</H3>
<OL>
  <LI>Expanded JavaScript functionality 
  <LI>Preliminary support for cascading stylesheets 
  <LI>Security fixes for file uploads: 
  <UL>
    <LI>Module will bail out if its temporary file already exists 
    <LI>Temporary files can now be made completely private to avoid peeking by 
    other users or CGI scripts. </LI></UL>
  <LI><CITE>use CGI qw/:nph/</CITE> wasn't working correctly. Now it is. 
  <LI>Cookie and HTTP date formats didn't meet spec. Thanks to Mark Fisher 
  (fisherm@indy.tce.com) for catching and fixing this. </LI></OL>p 
<H3>Version 2.35</H3>
<OL>
  <LI>Robustified multipart file upload against incorrect syntax in POST. 
  <LI>Fixed more problems with mod_perl. 
  <LI>Added -noScript parameter to start_html(). 
  <LI>Documentation fixes. </LI></OL>
<H3>Version 2.34</H3>
<OL>
  <LI>Stupid typo fix </LI></OL>
<H3>Version 2.33</H3>
<OL>
  <LI>Fixed a warning about an undefined environment variable. 
  <LI>Doug's patch for redirect() under mod_perl 
  <LI>Partial fix for busted inheritence from CGI::Apache 
  <LI>Documentation fixes. </LI></OL>
<H3>Version 2.32</H3>
<OL>
  <LI>Improved support for Apache's mod_perl. 
  <LI>Changes to better support inheritance. 
  <LI>Support for OS/2. </LI></OL>
<H3>Version 2.31</H3>
<OL>
  <LI>New <STRONG>uploadInfo()</STRONG> method to obtain header information from 
  uploaded files. 
  <LI><STRONG>cookie()</STRONG> without any arguments returns all the cookies 
  passed to a script. 
  <LI>Removed annoying warnings about $ENV{NPH} when running with the -w switch. 

  <LI>Removed operator overloading throughout to make compatible with new 
  versions of perl. 
  <LI><STRONG>-expires</STRONG> now implies the <STRONG>-date</STRONG> header, 
  to avoid clock skew. 
  <LI>WebSite passes cookies in $ENV{COOKIE} rather than $ENV{HTTP_COOKIE}. We 
  now handle this, even though it's O'Reilly's fault. 
  <LI>Tested successfully against new sfio I/O layer. 
  <LI>Documentation fixes. </LI></OL>
<H3>Version 2.30</H3>
<OL>
  <LI>Automatic detection of operating system at load time. 
  <LI>Changed select() function to Select() in order to avoid conflict with Perl 
  built-in. 
  <LI>Added Tr() as an alternative to TR(); some people think it looks better 
  that way. 
  <LI>Fixed problem with autoloading of MultipartBuffer::DESTROY code. 
  <LI>Added the following methods: 
  <UL>
    <LI>virtual_host() 
    <LI>server_software() </LI></UL>
  <LI>Automatic NPH mode when running under Microsoft IIS server. </LI></OL>
<H3>Version 2.29</H3>
<OL>
  <LI>Fixed cookie bugs 
  <LI>Fixed problems that cropped up when useNamedParameters was set to 1. 
  <LI>Prevent CGI::Carp::fatalsToBrowser() from crapping out when encountering a 
  die() within an eval(). 
  <LI>Fixed problems with filehandle initializers. </LI></OL>
<H3>Version 2.28</H3>
<OL>
  <LI>Added support for NPH scripts; also fixes problems with Microsoft IIS. 
  <LI>Fixed a problem with checkbox() values not being correctly saved and 
  restored. 
  <LI>Fixed a bug in which CGI objects created with empty string initializers 
  took on default values from earlier CGI objects. 
  <LI>Documentation fixes. </LI></OL>
<H3>Version 2.27</H3>
<OL>
  <LI>Small but important bug fix: the automatic capitalization of tag 
  attributes was accidentally capitalizing the VALUES as well as the ATTRIBUTE 
  names (oops). </LI></OL>
<H3>Version 2.26</H3>
<OL>
  <LI>Changed behavior of scrolling_list(), checkbox() and checkbox_group() 
  methods so that defaults are honored correctly. The "fix" causes endform() to 
  generate additional &lt;INPUT TYPE="HIDDEN"&gt; tags -- don't be surpised. 
  <LI>Fixed bug involving the detection of the SSL protocol. 
  <LI>Fixed documentation error in position of the -meta argument in 
  start_html(). 
  <LI>HTML shortcuts now generate tags in ALL UPPERCASE. 
  <LI>start_html() now generates correct SGML header: <PRE>      &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"&gt;
      </PRE>
  <LI>CGI::Carp no longer fails "use strict refs" pragma. </LI></OL>
<H3>Version 2.25</H3>
<OL>
  <LI>Fixed bug that caused bad redirection on destination URLs with arguments. 
  <LI>Fixed bug involving use_named_parameters() followed by 
  start_multipart_form() 
  <LI>Fixed bug that caused incorrect determination of binmode for Macintosh. 
  <LI>Spelling fixes on documentation. </LI></OL>
<H3>Version 2.24</H3>
<OL>
  <LI>Fixed bug that caused generation of lousy HTML for some form elements 
  <LI>Fixed uploading bug in Windows NT 
  <LI>Some code cleanup (not enough) </LI></OL>
<H3>Version 2.23</H3>
<OL>
  <LI>Fixed an obscure bug that caused scripts to fail mysteriously. 
  <LI>Fixed auto-caching bug. 
  <LI>Fixed bug that prevented HTML shortcuts from passing taint checks. 
  <LI>Fixed some -w warning problems. </LI></OL>
<H3>Version 2.22</H3>
<OL>
  <LI>New CGI::Fast module for use with FastCGI protocol. See pod documentation 
  for details. 
  <LI>Fixed problems with inheritance and autoloading. 
  <LI>Added TR() (&lt;tr&gt;) and PARAM() (&lt;param&gt;) methods to list of 
  exported HTML tag-generating functions. 
  <LI>Moved all CGI-related I/O to a bottleneck method so that this can be 
  overridden more easily in mod_perl (thanks to Doug MacEachern). 
  <LI>put() method as substitute for print() for use in mod_perl. 
  <LI>Fixed crash in tmpFileName() method. 
  <LI>Added tmpFileName(), startform() and endform() to export list. 
  <LI>Fixed problems with attributes in HTML shortcuts. 
  <LI>Functions that don't actually need access to the CGI object now no longer 
  generate a default one. May speed things up slightly. 
  <LI>Aesthetic improvements in generated HTML. 
  <LI>New examples. </LI></OL>
<H3>Version 2.21</H3>
<OL>
  <LI>Added the <CITE>-meta</CITE> argument to <CITE>start_html()</CITE>. 
  <LI>Fixed hidden fields (again). 
  <LI>Radio_group() and checkbox_group() now return an appropriate scalar value 
  when called in a scalar context, rather than returning a numeric value! 
  <LI>Cleaned up the formatting of form elements to avoid unesthetic extra 
  spaces within the attributes. 
  <LI>HTML elements now correctly include the closing tag when parameters are 
  present but null: em('') 
  <LI>Added password_field() to the export list. </LI></OL>
<H3>Version 2.20</H3>
<OL>
  <LI>Dumped the SelfLoader because of problems with running with taint checks 
  and rolled my own. Performance is now significantly improved. 
  <LI>Added HTML shortcuts. 
  <LI><CITE>import()</CITE> now adheres to the Perl module conventions, allowing 
  CGI.pm to import any or all method names into the user's name space. 
  <LI>Added the ability to initialize CGI objects from strings and associative 
  arrays. 
  <LI>Made it possible to initialize CGI objects with filehandle references 
  rather than filehandle strings. 
  <LI>Added the delete_all() and append() methods. 
  <LI>CGI objects correctly initialize from filehandles on NT/95 systems now. 
  <LI>Fixed the problem with binary file uploads on NT/95 systems. 
  <LI>Fixed bug in redirect(). 
  <LI>Added '-Window-target' parameter to redirect(). 
  <LI>Fixed import_names() so that parameter names containing funny characters 
  work. 
  <LI>Broke the unfortunate connection between cookie and CGI parameter name 
  space. 
  <LI>Fixed problems with hidden fields whose values are 0. 
  <LI>Cleaned up the documentation somewhat. </LI></OL>
<H3>Version 2.19</H3>
<OL>
  <LI>Added cookie() support routines. 
  <LI>Added -expires parameter to header(). 
  <LI>Added cgi-lib.pl compatability mode. 
  <LI>Made the module more configurable for different operating systems. 
  <LI>Fixed a dumb bug in JavaScript button() method. </LI></OL>
<H3>Version 2.18</H3>
<OL>
  <LI>Fixed a bug that corrects a hang that occurs on some platforms when 
  processing file uploads. Unfortunately this disables the check for bad 
  Netscape uploads. 
  <LI>Fixed bizarre problem involving the inability to process uploaded files 
  that begin with a non alphabetic character in the file name. 
  <LI>Fixed a bug in the hidden fields involving the -override directive being 
  ignored when scalar defaults were passed. 
  <LI>Added documentation on how to disable the SelfLoader features. </LI></OL>
<H3>Version 2.17</H3>
<OL>
  <LI>Added support for the SelfLoader module. 
  <LI>Added oodles of JavaScript support routines. 
  <LI>Fixed bad bug in query_string() method that caused some parameters to be 
  silently dropped. 
  <LI>Robustified file upload code to handle premature termination by the 
  client. 
  <LI>Exported temporary file names on file upload. 
  <LI>Removed spurious "uninitialized variable" warnings that appeared when 
  running under 5.002. 
  <LI>Added the Carp.pm library to the standard distribution. 
  <LI>Fixed a number of errors in this documentation, and probably added a few 
  more. 
  <LI>Checkbox_group() and radio_group() now return the buttons as arrays, so 
  that you can incorporate the individual buttons into specialized tables. 
  <LI>Added the '-nolabels' option to checkbox_group() and radio_group(). 
  Probably should be added to all the other HTML-generating routines. 
  <LI>Added the url() method to recover the URL without the entire query string 
  appended. 
  <LI>Added request_method() to list of environment variables available. 
  <LI>Would you believe it? Fixed hidden fields <EM>again</EM>! </LI></OL>
<H3>Version 2.16</H3>
<OL>
  <LI>Fixed hidden fields <EM>yet again</EM>. 
  <LI>Fixed subtle problems in the file upload method that caused intermittent 
  failures (thanks to Keven Hendrick for this one). 
  <LI>Made file upload more robust in the face of bizarre behavior by the 
  Macintosh and Windows Netscape clients. 
  <LI>Moved the POD documentation to the bottom of the module at the request of 
  Stephen Dahmen. 
  <LI>Added the -xbase parameter to the start_html() method, also at the request 
  of Stephen Dahmen. 
  <LI>Added JavaScript form buttons at Stephen's request. I'm not sure how to 
  use this Netscape extension correctly, however, so for now the form() method 
  is in the module as an undocumented feature. Use at your own risk! </LI></OL>
<H3>Version 2.15</H3>
<OL>
  <LI>Added the <B>-override</B> parameter to all field-generating methods. 
  <LI>Documented the <CODE>user_name()</CODE> and <CODE>remote_user()</CODE> 
  methods. 
  <LI>Fixed bugs that prevented empty strings from being recognized as valid 
  textfield contents. 
  <LI>Documented the use of framesets and added a frameset example. </LI></OL>
<H3>Version 2.14</H3>This was an internal experimental version that was never 
released. 
<H3>Version 2.13</H3>
<OL>
  <LI>Fixed a bug that interfered with the value "0" being entered into text 
  fields. </LI></OL>
<H3>Version 2.01</H3>
<OL>
  <LI>Added -rows and -columns to the radio and checkbox groups. No doubt this 
  will cause much grief because it seems to promise a level of meta-organization 
  that it doesn't actually provide. 
  <LI>Fixed a bug in the redirect() method -- it was not truly HTTP/1.0 
  compliant. </LI></OL>
<H3>Version 2.0</H3>The changes seemed to touch every line of code, so I decided 
to bump up the major version number. 
<OL>
  <LI>Support for <A 
  href="http://stein.cshl.org/WWW/software/CGI/#named_param">named parameter 
  style method calls.</A> This turns out to be a big win for extending CGI.pm 
  when Netscape adds new HTML "features". 
  <LI>Changed behavior of hidden fields back to the correct "sticky" behavior. 
  <A href="http://stein.cshl.org/WWW/software/CGI/#hidden_fields_warning">This 
  is going to break some programs,</A> but it is for the best in the long run. 
  <LI>Netscape 2.0b2 broke the file upload feature. CGI.pm now handles both 
  2.0b1 and 2.0b2-style uploading. It will probably break again in 2.0b3. 
  <LI>There were still problems with library being unable to distinguish between 
  a form being loaded for the first time, and a subsequent loading with all 
  fields blank. We now forcibly create a default name for the Submit button (if 
  not provided) so that there's always at least one parameter. 
  <LI>More workarounds to prevent annoying spurious warning messages when run 
  under the -w switch. -w is seriously broken in perl 5.001! </LI></OL>
<H3>Version 1.57</H3>
<OL>
  <LI>Support for the Netscape 2.0 "File upload" field. 
  <LI>The handling of defaults for selected items in scrolling lists and 
  multiple checkboxes is now consistent. </LI></OL>
<H3>Version 1.56</H3>
<OL>
  <LI>Created true "pod" documentation for the module. 
  <LI>Cleaned up the code to avoid many of the spurious "use of uninitialized 
  variable" warnings when running with the -w switch. 
  <LI>Added the <CODE>autoEscape()</CODE> method. v 
  <LI>Added string interpolation of the CGI object. 
  <LI>Added the ability to pass additional parameters to the &lt;BODY&gt; tag. 
  <LI>Added the ability to specify the status code in the HTTP header. </LI></OL>
<H3>Bug fixes in version 1.55</H3>
<OL>
  <LI>Every time self_url() was called, the parameter list would grow. This was 
  a bad "feature". 
  <LI>Documented the fact that you can pass "-" to radio_group() in order to 
  prevent any button from being highlighted by default. </LI></OL>
<H3>Bug fixes in version 1.54</H3>
<OL>
  <LI>The user_agent() method is now documented; 
  <LI>A potential security hole in import() is now plugged. 
  <LI>Changed name of import() to import_names() for compatability with CGI:: 
  modules. </LI></OL>
<H3>Bug fixes in version 1.53</H3>
<OL>
  <LI>Fixed several typos in the code that were causing the following 
  subroutines to fail in some circumstances 
  <OL>
    <LI>checkbox() 
    <LI>hidden() </LI></OL>
  <LI>No features added </LI></OL>
<H3>New features added in version 1.52</H3>
<OL>
  <LI>Added backslashing, quotation marks, and other shell-style escape 
  sequences to the parameters passed in during debugging off-line. 
  <LI>Changed the way that the hidden() method works so that the default value 
  always overrides the current one. 
  <LI>Improved the handling of sticky values in forms. It's now less likely that 
  sticky values will get stuck. 
  <LI>If you call server_name(), script_name() and several other methods when 
  running offline, the methods now create "dummy" values to work with. </LI></OL>
<H3>Bugs fixed in version 1.51</H3>
<OL>
  <LI>param() when called without arguments was returning an array of length 1 
  even when there were no parameters to be had. Bad bug! Bad! 
  <LI>The HTML code generated would break if input fields contained the 
  forbidden characters "&gt;&lt; or &amp;. You can now use these characters 
  freely. </LI></OL>
<H3>New features added in version 1.50</H3>
<OL>
  <LI>import() method allows all the parameters to be imported into a namespace 
  in one fell swoop. 
  <LI>Parameters are now returned in the same order in which they were defined. 
  </LI></OL>
<H3>Bugs fixed in version 1.45</H3>
<OL>
  <LI>delete() method didn't work correctly. This is now fixed. 
  <LI>reset() method didn't allow you to set the name of the button. Fixed. 
</LI></OL>
<H3>Bugs fixed in version 1.44</H3>
<OL>
  <LI>self_url() didn't include the path information. This is now fixed. 
</LI></OL>
<H3>New features added in version 1.43</H3>
<OL>
  <LI>Added the delete() method. </LI></OL>
<H3>New features added in version 1.42</H3>
<OL>
  <LI>The image_button() method to create clickable images. 
  <LI>A few bug fixes involving forms embedded in &lt;PRE&gt; blocks. </LI></OL>
<H3>New features added in version 1.4</H3>
<OL>
  <LI>New header shortcut methods 
  <UL>
    <LI>redirect() to create HTTP redirection messages. 
    <LI>start_html() to create the HTML title, complete with the recommended 
    &lt;LINK&gt; tag that no one ever remembers to include. 
    <LI>end_html() for completeness' sake. </LI></UL>
  <LI>A new save() method that allows you to write out the state of an script to 
  a file or pipe. 
  <LI>An improved version of the new() method that allows you to restore the 
  state of a script from a file or pipe. With (2) this gives you dump and 
  restore capabilities! (Wow, you can put a "121,931 customers served" banner at 
  the bottom of your pages!) 
  <LI>A self_url() method that allows you to create state-maintaining hypertext 
  links. In addition to allowing you to maintain the state of your scripts 
  between invocations, this lets you work around a problem that some browsers 
  have when jumping to internal links in a document that contains a form -- the 
  form information gets lost. 
  <LI>The user-visible labels in checkboxes, radio buttons, popup menus and 
  scrolling lists have now been decoupled from the values sent to your CGI 
  script. Your script can know a checkbox by the name of "cb1" while the user 
  knows it by a more descriptive name. I've also added some parameters that were 
  missing from the text fields, such as MAXLENGTH. 
  <LI>A whole bunch of methods have been added to get at environment variables 
  involved in user verification and other obscure features. </LI></OL>
<H3>Bug fixes</H3>
<OL>
  <LI>The problems with the hidden fields have (I hope at last) been fixed. 
  <LI>You can create multiple query objects and they will all be initialized 
  correctly. This simplifies the creation of multiple forms on one page. 
  <LI>The URL unescaping code works correctly now. </LI></OL><A 
href="http://stein.cshl.org/WWW/software/CGI/#contents">Table of Contents</A> 
<HR>

<ADDRESS>Lincoln D. Stein, lstein@cshl.org<BR><A 
href="http://www.cshl.org/">Cold Spring Harbor Laboratory</A></ADDRESS>
<P><!-- hhmts start -->Last modified: Wed Apr 10 15:35:26 EDT 2002 <!-- hhmts end --></P></BODY></HTML>
